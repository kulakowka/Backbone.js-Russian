<!DOCTYPE HTML>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="chrome=1" />
  <link rel="icon" href="docs/images/favicon.ico" />
  <title>Backbone.js по-русски</title>
  <style>
    body {
      font-size: 14px;
      line-height: 22px;
      font-family: Helvetica Neue, Helvetica, Arial;
      background: #f4f4f4 url(docs/images/background.png);
    }
    .interface {
      font-family: "Lucida Grande", "Lucida Sans Unicode", Helvetica, Arial, sans-serif !important;
    }
    div#sidebar {
      background: #fff;
      position: fixed;
      top: 0; left: 0; bottom: 0;
      width: 200px;
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
      padding: 15px 0 30px 30px;
      border-right: 1px solid #bbb;
      box-shadow: 0 0 20px #ccc; -webkit-box-shadow: 0 0 20px #ccc; -moz-box-shadow: 0 0 20px #ccc;
    }
      a.toc_title, a.toc_title:visited {
        display: block;
        color: black;
        font-weight: bold;
        margin-top: 15px;
      }
        a.toc_title:hover {
          text-decoration: underline;
        }
        #sidebar .version {
          font-size: 10px;
          font-weight: normal;
        }
      ul.toc_section {
        font-size: 11px;
        line-height: 14px;
        margin: 5px 0 0 0;
        padding-left: 0px;
        list-style-type: none;
        font-family: Lucida Grande;
      }
        .toc_section li {
          cursor: pointer;
          margin: 0 0 3px 0;
        }
          .toc_section li a {
            text-decoration: none;
            color: black;
          }
            .toc_section li a:hover {
              text-decoration: underline;
            }
    div.container {
      position: relative;
      width: 550px;
      margin: 40px 0 50px 260px;
    }
    div.run {
      position: absolute;
      right: 15px;
      width: 26px; height: 18px;
      background: url('docs/images/arrows.png') no-repeat -26px 0;
    }
      div.run:active {
        background-position: -51px 0;
      }
    p, div.container ul {
      margin: 25px 0;
      width: 550px;
    }
      p.warning {
        font-size: 12px;
        line-height: 18px;
        font-style: italic;
      }
      div.container ul {
        list-style: circle;
        padding-left: 15px;
        font-size: 13px;
        line-height: 18px;
      }
        div.container ul li {
          margin-bottom: 10px;
        }
        div.container ul.small {
          font-size: 12px;
        }
    a, a:visited {
      color: #444;
    }
    a:active, a:hover {
      color: #000;
    }
    a.punch {
      display: inline-block;
      background: #4162a8;
      border-top: 1px solid #38538c;
      border-right: 1px solid #1f2d4d;
      border-bottom: 1px solid #151e33;
      border-left: 1px solid #1f2d4d;
      -webkit-border-radius: 4px;
      -moz-border-radius: 4px;
      -ms-border-radius: 4px;
      -o-border-radius: 4px;
      border-radius: 4px;
      -webkit-box-shadow: inset 0 1px 10px 1px #5c8bee, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
      -moz-box-shadow: inset 0 1px 10px 1px #5c8bee, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
      -ms-box-shadow: inset 0 1px 10px 1px #5c8bee, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
      -o-box-shadow: inset 0 1px 10px 1px #5c8bee, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
      box-shadow: inset 0 1px 10px 1px #5c8bee, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
      color: #fff;
      font: bold 14px "helvetica neue", helvetica, arial, sans-serif;
      line-height: 1;
      margin-bottom: 15px;
      padding: 8px 0 10px 0;
      text-align: center;
      text-shadow: 0px -1px 1px #1e2d4d;
      text-decoration: none;
      width: 225px;
      -webkit-background-clip: padding-box; }
      a.punch:hover {
        -webkit-box-shadow: inset 0 0px 20px 1px #87adff, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
        -moz-box-shadow: inset 0 0px 20px 1px #87adff, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
        -ms-box-shadow: inset 0 0px 20px 1px #87adff, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
        -o-box-shadow: inset 0 0px 20px 1px #87adff, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
        box-shadow: inset 0 0px 20px 1px #87adff, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
        cursor: pointer; }
      a.punch:active {
        -webkit-box-shadow: inset 0 1px 10px 1px #5c8bee, 0 1px 0 #1d2c4d, 0 2px 0 #1f3053, 0 4px 3px 0 #111111;
        -moz-box-shadow: inset 0 1px 10px 1px #5c8bee, 0 1px 0 #1d2c4d, 0 2px 0 #1f3053, 0 4px 3px 0 #111111;
        -ms-box-shadow: inset 0 1px 10px 1px #5c8bee, 0 1px 0 #1d2c4d, 0 2px 0 #1f3053, 0 4px 3px 0 #111111;
        -o-box-shadow: inset 0 1px 10px 1px #5c8bee, 0 1px 0 #1d2c4d, 0 2px 0 #1f3053, 0 4px 3px 0 #111111;
        box-shadow: inset 0 1px 10px 1px #5c8bee, 0 1px 0 #1d2c4d, 0 2px 0 #1f3053, 0 4px 3px 0 #111111;
        margin-top: 5px; margin-bottom: 10px }
    a img {
      border: 0;
    }
    h1, h2, h3, h4, h5, h6 {
      padding-top: 20px;
    }
      h2 {
        font-size: 22px;
      }
    b.header {
      font-size: 18px;
      line-height: 35px;
    }
    span.alias {
      font-size: 14px;
      font-style: italic;
      margin-left: 20px;
    }
    table {
      margin: 15px 0 0; padding: 0;
    }
      tr, td {
        margin: 0; padding: 0;
      }
        td {
          padding: 0px 15px 5px 0;
        }
    code, pre, tt {
      font-family: Monaco, Consolas, "Lucida Console", monospace;
      font-size: 12px;
      line-height: 18px;
      font-style: normal;
    }
      tt {
        padding: 0px 3px;
        background: #fff;
        border: 1px solid #ddd;
        zoom: 1;
      }
      code {
        margin-left: 20px;
      }
      pre {
        font-size: 12px;
        padding: 2px 0 2px 15px;
        border: 4px solid #bbb; border-top: 0; border-bottom: 0;
        margin: 0px 0 25px;
      }
      img.example_image {
        margin: 0px auto;
      }
  </style>
</head>
<body>

  <div id="sidebar" class="interface">

    <a class="toc_title" href="#">
      Backbone.js <span class="version">(0.9.2)</span>
    </a>
    <ul class="toc_section">
      <li>&raquo; <a href="http://github.com/documentcloud/backbone">Репозиторий GitHub</a></li>
      <li>&raquo; <a href="docs/backbone.html">Исходный код с аннотациями</a></li>
    </ul>

    <a class="toc_title" href="#introduction">
      Введение
    </a>

    <a class="toc_title" href="#upgrading">
      Обновление версии
    </a>

    <a class="toc_title" href="#Events">
      События (Events)
    </a>
    <ul class="toc_section">
      <li>– <a href="#Events-on">on</a></li>
      <li>– <a href="#Events-off">off</a></li>
      <li>– <a href="#Events-trigger">trigger</a></li>
    </ul>

    <a class="toc_title" href="#Model">
      Модель (Model)
    </a>
    <ul class="toc_section">
      <li>– <a href="#Model-extend">extend</a></li>
      <li>– <a href="#Model-constructor">constructor / initialize</a></li>
      <li>– <a href="#Model-get">get</a></li>
      <li>– <a href="#Model-set">set</a></li>
      <li>– <a href="#Model-escape">escape</a></li>
      <li>– <a href="#Model-has">has</a></li>
      <li>– <a href="#Model-unset">unset</a></li>
      <li>– <a href="#Model-clear">clear</a></li>
      <li>– <a href="#Model-id">id</a></li>
      <li>– <a href="#Model-idAttribute">idAttribute</a></li>
      <li>– <a href="#Model-cid">cid</a></li>
      <li>– <a href="#Model-attributes">attributes</a></li>
      <li>– <a href="#Model-changed">changed</a></li>
      <li>– <a href="#Model-defaults">defaults</a></li>
      <li>– <a href="#Model-toJSON">toJSON</a></li>
      <li>– <a href="#Model-fetch">fetch</a></li>
      <li>– <a href="#Model-save">save</a></li>
      <li>– <a href="#Model-destroy">destroy</a></li>
      <li>– <a href="#Model-validate">validate</a></li>
      <li>– <a href="#Model-isValid">isValid</a></li>
      <li>– <a href="#Model-url">url</a></li>
      <li>– <a href="#Model-urlRoot">urlRoot</a></li>
      <li>– <a href="#Model-parse">parse</a></li>
      <li>– <a href="#Model-clone">clone</a></li>
      <li>– <a href="#Model-isNew">isNew</a></li>
      <li>– <a href="#Model-change">change</a></li>
      <li>– <a href="#Model-hasChanged">hasChanged</a></li>
      <li>– <a href="#Model-changedAttributes">changedAttributes</a></li>
      <li>– <a href="#Model-previous">previous</a></li>
      <li>– <a href="#Model-previousAttributes">previousAttributes</a></li>
    </ul>

    <a class="toc_title" href="#Collection">
      Коллекции (Collection)
    </a>
    <ul class="toc_section">
      <li>– <a href="#Collection-extend">extend</a></li>
      <li>– <a href="#Collection-model">model</a></li>
      <li>– <a href="#Collection-constructor">constructor / initialize</a></li>
      <li>– <a href="#Collection-models">models</a></li>
      <li>– <a href="#Collection-toJSON">toJSON</a></li>
      <li>– <a href="#Collection-Underscore-Methods"><b>Underscore Methods (28)</b></a></li>
      <li>– <a href="#Collection-add">add</a></li>
      <li>– <a href="#Collection-remove">remove</a></li>
      <li>– <a href="#Collection-get">get</a></li>
      <li>– <a href="#Collection-getByCid">getByCid</a></li>
      <li>– <a href="#Collection-at">at</a></li>
      <li>– <a href="#Collection-push">push</a></li>
      <li>– <a href="#Collection-pop">pop</a></li>
      <li>– <a href="#Collection-unshift">unshift</a></li>
      <li>– <a href="#Collection-shift">shift</a></li>
      <li>– <a href="#Collection-length">length</a></li>
      <li>– <a href="#Collection-comparator">comparator</a></li>
      <li>– <a href="#Collection-sort">sort</a></li>
      <li>– <a href="#Collection-pluck">pluck</a></li>
      <li>– <a href="#Collection-where">where</a></li>
      <li>– <a href="#Collection-url">url</a></li>
      <li>– <a href="#Collection-parse">parse</a></li>
      <li>– <a href="#Collection-fetch">fetch</a></li>
      <li>– <a href="#Collection-reset">reset</a></li>
      <li>– <a href="#Collection-create">create</a></li>
    </ul>

    <a class="toc_title" href="#Router">
      Роутер (Router)
    </a>
    <ul class="toc_section">
      <li>– <a href="#Router-extend">extend</a></li>
      <li>– <a href="#Router-routes">routes</a></li>
      <li>– <a href="#Router-constructor">constructor / initialize</a></li>
      <li>– <a href="#Router-route">route</a></li>
      <li>– <a href="#Router-navigate">navigate</a></li>
    </ul>

    <a class="toc_title" href="#History">
      История (History)
    </a>
    <ul class="toc_section">
      <li>– <a href="#History-start">start</a></li>
    </ul>

    <a class="toc_title" href="#Sync">
      Синхронизация (Sync)
    </a>
    <ul class="toc_section">
      <li>– <a href="#Sync">Backbone.sync</a></li>
      <li>– <a href="#Sync-emulateHTTP">Backbone.emulateHTTP</a></li>
      <li>– <a href="#Sync-emulateJSON">Backbone.emulateJSON</a></li>
    </ul>

    <a class="toc_title" href="#View">
      Представление (View)
    </a>
    <ul class="toc_section">
      <li>– <a href="#View-extend">extend</a></li>
      <li>– <a href="#View-constructor">constructor / initialize</a></li>
      <li>– <a href="#View-el">el</a></li>
      <li>– <a href="#View-$el">$el</a></li>
      <li>– <a href="#View-setElement">setElement</a></li>
      <li>– <a href="#View-attributes">attributes</a></li>
      <li>– <a href="#View-dollar">$ (jQuery или Zepto)</a></li>
      <li>– <a href="#View-render">render</a></li>
      <li>– <a href="#View-remove">remove</a></li>
      <li>– <a href="#View-make">make</a></li>
      <li>– <a href="#View-delegateEvents">delegateEvents</a></li>
      <li>– <a href="#View-undelegateEvents">undelegateEvents</a></li>
    </ul>

    <a class="toc_title" href="#Utility">
      Утилитные методы (Utility)
    </a>
    <ul class="toc_section">
      <li>– <a href="#Utility-noConflict">noConflict</a></li>
      <li>– <a href="#Utility-setDomLibrary">setDomLibrary</a></li>
    </ul>

    <a class="toc_title" href="#examples">
      Примеры (Examples)
    </a>
    <ul class="toc_section">
      <li>– <a href="#examples-todos">Todos</a></li>
      <li>– <a href="#examples-documentcloud">DocumentCloud</a></li>
      <li>– <a href="#examples-linkedin">LinkedIn Mobile</a></li>
      <li>– <a href="#examples-foursquare">Foursquare</a></li>
      <li>– <a href="#examples-khan-academy">Khan Academy</a></li>
      <li>– <a href="#examples-basecamp">Basecamp Mobile</a></li>
    </ul>

    <a class="toc_title" href="#faq">
      F.A.Q.
    </a>
    <ul class="toc_section">
      <li>– <a href="#FAQ-events">Каталог событий</a></li>
      <li>– <a href="#FAQ-tim-toady">Больше, чем один способ  сделать это</a></li>
      <li>– <a href="#FAQ-nested">Вложенные модели и коллекции</a></li>
      <li>– <a href="#FAQ-bootstrap">Предзагрузка моделей</a></li>
      <li>– <a href="#FAQ-extending">Расширяем Backbone</a></li>
      <li>– <a href="#FAQ-mvc">Традиционное MVC</a></li>
      <li>– <a href="#FAQ-this">Привязка "this"</a></li>
      <li>– <a href="#FAQ-rails">Работа с Rails</a></li>
    </ul>

    <a class="toc_title" href="#changelog">
      Чейнджлог
    </a>

  </div>

  <div class="container">

    <p>
      <img style="width: 451px; height: 150px;" src="docs/images/backbone.png" alt="Backbone.js" />
    </p>

    <p>
      Backbone.js придает структуру веб-приложениям с помощью
      <b>моделей</b> с биндингами по ключу и пользовательскими событиями,
      <b>коллекций</b> с богатым набором методов с перечислимыми сущностями,
      <b>представлений</b> с декларативной обработкой событий; и соединяет это все
      с вашим существующим REST-овым JSON API.
    </p>

    <p>
      Проект <a href="http://github.com/documentcloud/backbone/">размещается на GitHub</a>,
      с доступным <a href="docs/backbone.html">аннотированным исходным кодом</a>,
      с онлайновыми <a href="test/test.html">тестами</a>,
      с <a href="examples/todos/index.html">примером приложения</a>,
      со <a href="https://github.com/documentcloud/backbone/wiki/Tutorials%2C-blog-posts-and-example-sites">списком туториалов</a>
      и <a href="#examples">большим списком реальных проектов</a>, которые используют Backbone.
      Backbone доступен под <a href="http://github.com/documentcloud/backbone/blob/master/LICENSE">лицензией MIT</a>.
    </p>

    <p>
      Оставляйте баг-репорты и обсуждайте фичи на
      <a href="http://github.com/documentcloud/backbone/issues">в багтрекере на GitHub'е</a>,
      на IRC-канале Freenode <tt>#documentcloud</tt>, задавайте вопросы в
      <a href="https://groups.google.com/forum/#!forum/backbonejs">группу Google</a>,
      добавляйте страницы в <a href="https://github.com/documentcloud/backbone/wiki">вики</a>,
      или шлите твиты <a href="http://twitter.com/documentcloud">@documentcloud</a>.
    </p>

    <p>
      <i>
        Backbone — это компонент <a href="http://documentcloud.org/">DocumentCloud</a> c открытым исходным кодом.
      </i>
    </p>

    <h2 id="downloads">
      Загрузка и зависимости
      <span style="padding-left: 7px; font-size:11px; font-weight: normal;" class="interface">(ПКМ и "Сохранить как")</span>
    </h2>

    <table>
      <tr>
        <td><a class="punch" href="backbone.js">Версия для разработки (0.9.2)</a></td>
        <td><i>52кб, полный код, много комментариев</i></td>
      </tr>
      <tr>
        <td><a class="punch" href="backbone-min.js">Production-версия (0.9.2)</a></td>
        <td><i>5.6кб, упакованная и gzip-ованная</i></td>
      </tr>
    </table>

    <p>
      Единственная жесткая зависимость в Backbone —
      <a href="http://documentcloud.github.com/underscore/">Underscore.js</a> <small>( > 1.3.1)</small>.
      Для RESTful-персистентности, поддержки истории с помощью <a href="#Router">Backbone.Router</a>
      и операций с DOM в <a href="#View">Backbone.View</a>, подключите
      <a href="https://github.com/douglascrockford/JSON-js">json2.js</a>, и либо
      <a href="http://jquery.com">jQuery</a> <small>( > 1.4.2)</small> либо
      <a href="http://zeptojs.com/">Zepto</a>.
    </p>

    <h2 id="introduction">Введение</h2>

    <p>
      При работе с веб-приложением, которое включает в себя много JavaScript,
      первое, чему вы научитесь — это перестать связывать ваши данные с DOM, потому что
      это подходит только для создания простых JavaScript приложений,
      которые в конечном итоге выглядят,
      как запутанные груды jQuery-селекторов и коллбэков,
      которые отчаянно пытаются хранить актуализированные данные в UI,
      JavaScript логике и базе данных на сервере.
      Для сложных клиентских приложений часто бывает полезным более структурированный подход.
    </p>

    <p>
      Работая с Backbone, вы представляете ваши данные как <a href="#Model">Модели (Models)</a>,
      которые могут быть созданы, провалидированы, удалены, и сохранены на сервере.
      Всякий раз, когда в интерфейсе изменяется атрибуты модели, модель вызывает событие <i>"change"</i>;
      все <a href="#View">Представления (Views)</a>,
      которые отображают состояние модели, могут быть уведомлены об изменении атрибутов модели,
      с тем чтобы они могли отреагировать соответствующим образом — например,
      перерисовать себя с учетом новых данных.
      В готовом приложении на Backbone, вы не должны писать код,
      ищущий элемент с определенным id в DOM
      и обновлять HTML вручную. При изменении модели представление просто обновит себя самостоятельно.
    </p>

    <p>
      Если вы новичок и еще не совсем уверены, что Backbone вам подходит,
      начните с просмотра <a href="#examples">списка проектов, использующих Backbone</a>.
    </p>

    <p>
      Многие из следующих примеров рабоспособны.
      Нажмите кнопку <i>play</i>, чтобы запустить их.
    </p>

    <h2 id="upgrading">Обновление до версии 0.9</h2>

    <p>
      Backbone версий <b>0.9</b> должен считаться кандидатом на релиз к грядущей версии
      <b>1.0</b>. Некоторые API изменились, и, хотя есть
      список изменений, и многие новые фичи используют эти изменения,
      есть несколько специфических изменений, которые вы должны принять во внимание:
    </p>

    <ul>
      <li>
        Если вы раньше вручную назначали <tt>this.el</tt> в представлении Backbone,
        вместо этого теперь лучше использовать <a href="#View-setElement">setElement</a>.
      </li>
      <li>
        Создание и уничтожение моделей теперь оптимистично. Передайте <tt>{wait: true}</tt>,
        если вам нужно предудыщее поведение, когда ожидался ответ сервера об успехе.
        Также можно передать <tt>{wait: true}</tt> в вызовы <a href="#Model-save">save</a>.
      </li>
      <li>
        Раньше часто приходилось писать <tt>$(view.el)</tt>; теперь
        есть закэшированная ссылка на этот jQuery-объект: <a href="#View-$el">$el</a>.
      </li>
      <li>
        Если вы обновляете Backbone, обновите и Underscore.js до последней версии —
        1.3.1 или выше.
      </li>
      <li>
        Если с помощью <tt>model.set</tt> изменить какие-либо атрибуты, а потом вернуть к изначальным значениям,
        при опции <tt>{silent: true}</tt> теперь не будет запущено событие <tt>change</tt>
        Также после «молчаливого» изменения атрибута событие <tt>change:attribute</tt>
        <i>будет</i> запущено во время следующего изменения.
      </li>
      <li>
        Так как <tt>view.$(selector)</tt> теперь эквивалентно <tt>view.$el.find(selector)</tt>
        а не <tt>$(selector, view.el)</tt>, теперь нельзя передавать в параметре
        <tt>selector</tt> HTML-строку или DOM-элемент.
      </li>
    </ul>

    <h2 id="Events">Backbone.Events</h2>

    <p>
      <b>Events</b> — это модуль, который может расширить возможности любого объекта,
      давая ему способность отслеживать и вызывать именованные пользовательские события.
      События должны быть объявлены после примешивания модуля.
      В событие можно передавать аргументы. Например:
    </p>

<pre class="runnable">
var object = {};

_.extend(object, Backbone.Events);

object.on("alert", function(msg) {
  alert("Сработало " + msg);
});

object.trigger("alert", "событие");
</pre>

    <p>
      Например, можно сделать удобный диспетчер событий,
      который будет координировать события между различными областями приложения:<br/>
      <tt>var dispatcher = _.clone(Backbone.Events)</tt>
    </p>

    <p id="Events-on">
      <b class="header">on</b><code>object.on(event, callback, [context])</code><span class="alias">Синоним: bind</span>
      <br />
      Привязывает функцию-обработчик <b>callback</b> к объекту,
      который будет вызываться всякий раз, когда сработает событие <b>event</b>.
      Если у вас используется множество различных событий на странице, следует использовать двоеточия в названиях:
      <tt>"poll:start"</tt>, или <tt>"change:selection"</tt>.
      Строка названия события (event) может состоять из разделенных пробелами нескольких событий...
    </p>

<pre>
book.on("change:title change:author", ...);
</pre>

    <p>Чтобы сохранить контекст, с которым должен быть вызван обработчик,
      передайте третий необязательный аргумент <b>context</b>:<br/>
      <tt>model.on('change', this.render, this)</tt>
    </p>

    <p>
      Существует специальное значение <tt>"all"</tt>,
      которое можно указать в качестве названия события.
      Такой обработчик будет срабатывать при возникновении любого события.
      Название события будет передаваться в него в первом аргументе.
      Это можно использовать, например, для проксирования всех событий от одного объекта к другому:
    </p>

<pre>
proxy.on("all", function(eventName) {
  object.trigger(eventName);
});
</pre>

    <p id="Events-off">
      <b class="header">off</b><code>object.off([event], [callback], [context])</code><span class="alias">Синоним: unbind</span>
      <br />
      Удаляет привязанный ранее обработчик.
      Если параметр <b>context</b> не задан, все версии обработчика будут удалены, независимо от контекста.

      Если не указан обработчик, будут удалены все обработчики для события <b>event</b>.
      Если не указано событие, <b>все</b> будут удалены все обработчики.
    </p>

<pre>
// Удаляет только обработчик `onChange`.
object.off("change", onChange);

// Удаляет все обработчики события "change".
object.off("change");

// Удаляет все обработчики `onChange` для всех событий.
object.off(null, onChange);

// Удаляет все обработчики в контексте `context` для всех событий.
object.off(null, null, context);

// Удаляет все обработчики для объекта `object`.
object.off();
</pre>

    <p id="Events-trigger">
      <b class="header">trigger</b><code>object.trigger(event, [*args])</code>
      <br />
      Вызывает срабатывание события <b>event</b> (или группы событий — разделенных пробелами).
      Последующие аргументы в <b>trigger</b> будут переданы вместе с событием в обработчик.
    </p>

    <h2 id="Model">Backbone.Model</h2>

    <p>
      <b>Модели</b> — это самое сердце любого JavaScript-приложения.
      Они содержат как интерактивные данные, так и большую часть соответствующей логики:
	    конвертации, валидации, вычисленные свойства, и контроль доступа. Вы расширяете
  	  <b>Backbone.Model</b> методами своей предметной области, а <b>Model</b>
	    предоставляет базовый набор функциональности по управлению изменениями.
    </p>

    <p>
      Нижеприведенный пример спорен, но он демонстрирует определение модели с пользовательским
	    методом, установку атрибута, и запуск события, привязанного к этому атрибуту.
      После запуска этого кода <tt>sidebar</tt> станет доступен в консоли браузера,
	    так что можно будет с ним поиграться.
    </p>

<pre class="runnable">
var Sidebar = Backbone.Model.extend({
  promptColor: function() {
    var cssColor = prompt("Пожалуйста, введите CSS-цвет:");
    this.set({color: cssColor});
  }
});

window.sidebar = new Sidebar;

sidebar.on('change:color', function(model, color) {
  $('#sidebar').css({background: color});
});

sidebar.set({color: 'white'});

sidebar.promptColor();
</pre>

    <p id="Model-extend">
      <b class="header">extend</b><code>Backbone.Model.extend(properties, [classProperties])</code>
      <br />
      Чтобы создать свой собственный класс моделей, нужно расширить <b>Backbone.Model</b>
      и предоставить свойства экземпляра в параметре <b>properties</b>; опциональный параметр
      <b>classProperties</b> отвечает за свойства, которые будут прицеплены напрямую к функции-конструктору.
    </p>

    <p>
      <b>extend</b> корректно устанавливает цепочку прототипов, так что дочерние классы,
	    созданные с помощью <b>extend</b> могут дальше расширяться и наследоваться, сколько угодно.
    </p>

<pre>
var Note = Backbone.Model.extend({

  initialize: function() { ... },

  author: function() { ... },

  coordinates: function() { ... },

  allowedToEdit: function(account) {
    return true;
  }

});

var PrivateNote = Note.extend({

  allowedToEdit: function(account) {
    return account.owns(this);
  }

});
</pre>

    <p class="warning">
      Небольшое замечание о <tt>super</tt>: JavaScript не предоставляет простого способа
      вызвать родительский метод &mdash; функцию с таким же именем, определенную выше
      в цепочке прототипов. Если вы переопределяете функцию ядра, например
      <tt>set</tt>, или <tt>save</tt>, и хотите вызвать родительскую имплементацию,
  	  вам придется вручную вызвать ее примерно вот так:
    </p>

<pre>
var Note = Backbone.Model.extend({
  set: function(attributes, options) {
    Backbone.Model.prototype.set.call(this, attributes, options);
    ...
  }
});
</pre>

    <p id="Model-constructor">
      <b class="header">constructor / initialize</b><code>new Model([attributes], [options])</code>
      <br />
      Можно передать начальные значения атрибутов, создавая экземпляр модели —
	    параметр <b>attributes</b> будет передан в метод <a href="#Model-set">set</a>.
	    Если вы определите функцию <b>initialize</b>, она будет вызвана после создания модели.
    </p>

<pre>
new Book({
  title: "Тысяча и одна ночь",
  author: "Шахерезада"
});
</pre>

    <p>
      В редких случаях, если вам досталось что-то особенное,
      может понадобиться переопределить <b>constructor</b> — это позволит заменить
      настоящую функцию-конструктор для вашей модели.
    </p>

    <p>
      Если вы передаете <tt>{collection: ...}</tt> в качестве параметра <b>options</b>,
      модель получит свойство <tt>collection</tt>, которое будет использовано для индикации того,
      к какой коллекции принадлежит данная модель, и для того, чтобы вычислить свойство
      <a href="#Model-url">url</a>. В противном случае свойство <tt>model.collection</tt>
      будет добавлено автоматически в момент первого добавления модели в коллекцию.
    </p>

    <p id="Model-get">
      <b class="header">get</b><code>model.get(attribute)</code>
      <br />
      Отдает текущее значение атрибута модели, например:
      <tt>note.get("title")</tt>
    </p>

    <p id="Model-set">
      <b class="header">set</b><code>model.set(attributes, [options])</code>
      <br />
      Хэш <b>attributes</b> устанавливает значения атрибутам (одному или многим).
  	  Если любой из атрибутов изменяет состояние модели, то сработает событие <tt>"change"</tt> —
	    если только вы не передали <tt>{silent: true}</tt> в параметре <b>options</b>. События изменения
	    для каждого из атрибутов (например, <tt>change:title</tt>, или <tt>change:content</tt>)
	    сработают точно так же, и вы точно так же можете привязать к ним слушатели.<br />
	    Так же можно передать отдельный ключ и значение:
    </p>

<pre>
note.set({title: "20-ого марта", content: "В его глазах она затмевала…"});

book.set("title", "Скандал в Богемии");
</pre>

    <p>
      Если у модели определен метод <a href="#Model-validate">validate</a>,
      значения будут отвалидированы перед установкой атрибутов. Если значения не пройдут валидацию,
      изменений не произойдет, и <b>set</b> вернет <tt>false</tt>. В противном случае <b>set</b>
	    возвращает ссылку на экземпляр модели.
      Также можно передать <tt>error</tt>-коллбэк в <b>options</b>, который будет
	    вызван вместо запуска события <tt>"error"</tt>, если валидация провалится.
      Если передать <tt>{silent: true}</tt> в опциях, то валидация будет отложена до следующего изменения.
    </p>

    <p id="Model-escape">
      <b class="header">escape</b><code>model.escape(attribute)</code>
      <br />
      Этот метод похож на <a href="#Model-get">get</a>, но возвращает HTML-безопасную версию
      атрибута. Если вы вставляете данные из модели в HTML, использование <b>escape</b>
	    для получения атрибута предотвратит
      <a href="http://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%B6%D1%81%D0%B0%D0%B9%D1%82%D0%BE%D0%B2%D1%8B%D0%B9_%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%B8%D0%BD%D0%B3">XSS</a>-атаки.
    </p>

<pre class="runnable">
var hacker = new Backbone.Model({
  name: "&lt;script&gt;alert('xss')&lt;/script&gt;"
});

alert(hacker.escape('name'));
</pre>

    <p id="Model-has">
      <b class="header">has</b><code>model.has(attribute)</code>
      <br />
      Возвращает <tt>true</tt>, если атрибут установлен не в <tt>null</tt> и не в <tt>undefined</tt>.
    </p>

<pre>
if (note.has("title")) {
  ...
}
</pre>

    <p id="Model-unset">
      <b class="header">unset</b><code>model.unset(attribute, [options])</code>
      <br />
      Убирает атрибут, удаляя его из внутреннего хэша атрибутов.
      Запускает событие <tt>"change"</tt>, если не передать <tt>silent</tt> в опциях.
    </p>

    <p id="Model-clear">
      <b class="header">clear</b><code>model.clear([options])</code>
      <br />
      Убирает все атрибуты из модели. Запускает событие <tt>"change"</tt>, если не передать <tt>silent</tt> в опциях.
    </p>

    <p id="Model-id">
      <b class="header">id</b><code>model.id</code>
      <br />
      Специальное свойство модели <b>id</b> — произвольная строка (целый id или UUID).
	    Если вы указываете <b>id</b> в хэше атрибутов, он будет скопирован в свойство модели напрямую.
      Модели могут быть вытащены из коллекций по id, и id используется для генерации URL по умолчанию.
    </p>

    <p id="Model-idAttribute">
      <b class="header">idAttribute</b><code>model.idAttribute</code>
      <br />
      Уникальный идентификатор модели хранится в атрибуте <tt>id</tt>.
      Если ваше приложение напрямую коммуницирует с бэк-ендом (CouchDB, MongoDB), который использует
      другой уникальный ключ, вы можете указать <tt>idAttribute</tt>, чтобы прозрачно мапить этот ключ на <tt>id</tt>.

<pre class="runnable">
var Meal = Backbone.Model.extend({
  idAttribute: "_id"
});

var cake = new Meal({ _id: 1, name: "Пирожок" });
alert("id пирожка: " + cake.id);
</pre>
    </p>

    <p id="Model-cid">
      <b class="header">cid</b><code>model.cid</code>
      <br />
      Специальное свойство моделей <b>cid</b> (от client id, клиентский id) — уникальный идентификатор,
      автоматически назначающийся всем моделям в момент создания экземпляра. cid'ы удобны,
      когда модель еще не была сохранена на сервер, и не имеет своего настоящего <b>id</b>,
	    но уже должна быть отображена в UI.
      Клиентские id'ы принимают вид: <tt>c1, c2, c3 ...</tt>
    </p>

    <p id="Model-attributes">
      <b class="header">attributes</b><code>model.attributes</code>
      <br />
      Свойство <b>attributes</b> — это внутренний хэш, содержащий состояние модели.
  	  Лучше использовать метод <a href="#Model-set">set</a> для обновления атрибутов
	    вместо прямого изменения этого хэша.
	    Если вам нужны атрибуты, который не жаль испортить, можно получить копию
	    с помощью метода <a href="#Model-toJSON">toJSON</a>.
    </p>

    <p id="Model-changed">
      <b class="header">changed</b><code>model.changed</code>
      <br />
      Свойство <b>changed</b> — это внутренний хэш, содержащий все атрибуты, которые были изменены
	    с тех пор, как последний раз срабатывало событие <tt>"change"</tt>.
      Пожалуйста, не обновляйте <b>changed</b> напрямую. Его состояние поддерживается внутри
      методами <a href="#Model-set">set</a> и <a href="#Model-change">change</a>.
      Копию <b>changed</b> можно получить через <a href="#Model-changedAttributes">changedAttributes</a>.
    </p>

    <p id="Model-defaults">
      <b class="header">defaults</b><code>model.defaults или model.defaults()</code>
      <br />
      Хэш (или функция) <b>defaults</b> используется для указания значений атрибутов
	    по умолчанию. Если в момент создания экземпляра модели какие-то атрибуты не будут указаны, 
      то они примут значения по умолчанию.
    </p>

<pre class="runnable">
var Meal = Backbone.Model.extend({
  defaults: {
    "appetizer":  "Салат «Цезарь»",
    "entree":     "Равиоли",
    "dessert":    "Чиз-кейк"
  }
});

alert("На десерт: " + (new Meal).get('dessert'));
</pre>

    <p class="warning">
      Помните, что в JavaScript объекты передаются по ссылке —
	    так что, если какое-либо значение по умолчанию будет объектом,
	    оно будет одним для всех экземпляров.
    </p>

    <p id="Model-toJSON">
      <b class="header">toJSON</b><code>model.toJSON()</code>
      <br />
      Возвращает копию поля <a href="#Model-attributes">attributes</a> для превращения в JSON-строку.
      Метод может быть использован для персистентности, сериализации или для аугментации перед
	    передачей в представление.
	    Имя этого метода несколько сбивает с толку, так как он на самом деле не возвращает JSON-строку,
	    но именно так работает <a href="https://developer.mozilla.org/en/JSON#toJSON()_method">JavaScript API для <b>JSON.stringify</b></a>.
    </p>

<pre class="runnable">
var artist = new Backbone.Model({
  firstName: "Василий",
  lastName: "Кандинский"
});

artist.set({birthday: "December 16, 1866"});

alert(JSON.stringify(artist));
</pre>

    <p id="Model-fetch">
      <b class="header">fetch</b><code>model.fetch([options])</code>
      <br />
      Обновляет состояние модели данными с сервера с помощью
      <a href="#Sync">Backbone.sync</a>. Возвращает
      <a href="http://api.jquery.com/jQuery.ajax/#jqXHR">jqXHR</a>.
      Полезен, если модель никогда не наполнялась данными, или если вы хотите
      удостовериться, что вы имеете актуальные данные. Событие <tt>"change"</tt>
	    сработает, если состояние сервера отличается от текущих атрибутов.
	    Принимает коллбэки <tt>success</tt> и <tt>error</tt> в хэше <b>options</b>,
	    в которые передаются <tt>(model, response)</tt> в качестве аргументов.
    </p>

<pre>
// Опрашивать каждые 10 секунд, чтобы хранить модель канала в актуальном состоянии.
setInterval(function() {
  channel.fetch();
}, 10000);
</pre>

    <p id="Model-save">
      <b class="header">save</b><code>model.save([attributes], [options])</code>
      <br />
      Сохраняет модель в БД (или другой слой персистентности) при помощи <a href="#Sync">Backbone.sync</a>.
	    Возвращает <a href="http://api.jquery.com/jQuery.ajax/#jqXHR">jqXHR</a>, если валидация прошла успешно,
	    и <tt>false</tt> в противном случае. Хэш <b>attributes</b> (также, как в <a href="#Model-set">set</a>),
  	  должен содержать атрибуты, которые вы хотите изменить — ключи, которые не были указаны, не будут изменены.
	    Однако, на сервер будет послано <i>полное представление</i> ресурса.
      Также, как и в <tt>set</tt>, можно передать отдельный ключ и значение вместо хэша.
      Если у модели определен метод <a href="#Model-validate">validate</a>, и валидация не проходит успешно,
	    модель не будет сохранена.
      Если флаг <a href="#Model-isNew">isNew</a> модели установлен в <tt>true</tt>,
	    сохранение будет действием <tt>"create"</tt>(HTTP-глагол <tt>POST</tt>);
      если модель уже существует на сервере — <tt>"update"</tt> (HTTP-глагол <tt>PUT</tt>).
    </p>

    <p>
      Вызов <tt>save</tt> с новыми атрибутами немедленно вызовет срабатывание события <tt>"change"</tt>,
      и события <tt>"sync"</tt> — после того, как сервер известит об успешном изменении.
	    Передайте <tt>{wait: true}</tt>, если хотите подождать ответа сервера, прежде чем устанавливать
  	  новые значения атрибутов модели.
    </p>

    <p>
      Обратите внимание, как в следующем примере наша переопределенная версия <tt>Backbone.sync</tt>
	    получает запрос <tt>"create"</tt> в первый раз, когда сохраняется модель, и <tt>"update"</tt>
      во второй раз.
    </p>

<pre class="runnable">
Backbone.sync = function(method, model) {
  alert(method + ": " + JSON.stringify(model));
  model.id = 1;
};

var book = new Backbone.Model({
  title: "Малая Земля",
  author: "Леонид Брежнев"
});

book.save();

book.save({author: "Лёня"});
</pre>

    <p>
      <b>save</b> принимает коллбэки <tt>success</tt> и <tt>error</tt> в хэше <b>options</b>,
	    в которые передаются <tt>(model, response)</tt> в качестве аргументов.
      Коллбэк <tt>error</tt> также будет вызван, если у модели определен метод
      <tt>validate</tt>, и валидация проваливается. Если проваливается валидация на стороне сервера,
	    верните не-<tt>2XX</tt> HTTP-статус, вместе с описанием ошибки в тексте или в JSON.
    </p>

<pre>
book.save("author", "У.К. Черненко", {error: function(){ ... }});
</pre>

    <p id="Model-destroy">
      <b class="header">destroy</b><code>model.destroy([options])</code>
      <br />
      Уничтожает модель на сервере с помощью HTTP-запроса <tt>DELETE</tt>
      через <a href="#Sync">Backbone.sync</a>. Возвращает объект
      <a href="http://api.jquery.com/jQuery.ajax/#jqXHR">jqXHR</a>, или
      <tt>false</tt>, если флаг <a href="#Model-isNew">isNew</a> истинен. Принимает коллбэки
      <tt>success</tt> и <tt>error</tt> в хэше <b>options</b>.
      Запускает событие <tt>"destroy"</tt> на модели, которое всплывет на всех коллекциях,
	    которые содержат её; и событие <tt>"sync"</tt> после того, как сервер известит об успешном удалении модели.
	    Передайте <tt>{wait: true}</tt>, если хотите подождать ответа сервера, прежде чем удалять модель.
    </p>

<pre>
book.destroy({success: function(model, response) {
  ...
}});
</pre>

    <p id="Model-validate">
      <b class="header">validate</b><code>model.validate(attributes)</code>
      <br />
      Этот метод оставлен неопределенным; поощряется переопределять его со своей логикой валидации — если у вас есть такая, которую можно выполнить на стороне клиента. Метод <b>validate</b> вызывается перед <tt>set</tt> и
      <tt>save</tt>, и ему передаются атрибуты модели, обновленные значениями из <tt>set</tt> или <tt>save</tt>.
      Если атрибуты валидны, не возвращайте ничего из <b>validate</b>;
      если нет, возвращайте любую ошибку на ваш выбор — как просто
	    строку с сообщением, которое надо отобразить, так и сложный объект, программно описывающий ошибку.
  	  Если <b>validate</b> вернул ошибку, выполнение <tt>set</tt> или <tt>save</tt> прервется,
  	  и атрибуты модели не будут изменены.
      Проваленная валидация запустит событие <tt>"error"</tt>.
    </p>

<pre class="runnable">
var Chapter = Backbone.Model.extend({
  validate: function(attrs) {
    if (attrs.end < attrs.start) {
      return "Невозможно закончить до начала";
    }
  }
});

var one = new Chapter({
  title : "Глава I: Начало"
});

one.on("error", function(model, error) {
  alert(model.get("title") + " " + error);
});

one.set({
  start: 15,
  end:   10
});
</pre>

    <p>
      События <tt>"error"</tt> полезны для грубой обработки ошибок на уровне модели или коллекции,
	    но если у вас есть специфичное представление, которое может лучше обработать ошибку, вы можете подавить
	    событие, напрямую передав <tt>error</tt>-коллбэк:
    </p>

<pre>
account.set({access: "unlimited"}, {
  error: function(model, error) {
    alert(error);
  }
});
</pre>

    <p id="Model-isValid">
      <b class="header">isValid</b><code>model.isValid()</code>
      <br />
      Модели могут войти в невалидное состояние, если делать изменения
	    с подавлением ошибок… что полезно в случае работы с формами ввода.
	    Вызовите <tt>model.isValid()</tt> чтобы проверить, находится ли
	    сейчас модель в валидном состоянии согласно вашему методу <tt>validate</tt>.
    </p>

    <p id="Model-url">
      <b class="header">url</b><code>model.url()</code>
      <br />
      Возвращает относительный URL, по которому ресурс модели должен располагаться
	    на сервере. Если ваши модели расположены в другом месте, переопределите этот метод
	    с правильной логикой. Генерирует URL'ы вида: <tt>"/[collection.url]/[id]"</tt>,
      с откатом к <tt>"/[urlRoot]/id"</tt>, если модель не является частью коллекции.
    </p>

    <p>
      Обращается к <a href="#Collection-url">Collection#url</a>, чтобы сгенерировать URL,
	    так что удостоверьтесь, что он определен, или к свойству <a href="#Model-urlRoot">urlRoot</a> модели,
  	  если все модели этого класса разделают общий корневой URL.
      Модель с id равным <tt>101</tt>, хранящяяся в
      <a href="#Collection">коллекции</a> с <tt>url</tt> равным <tt>"/documents/7/notes"</tt>,
      будет иметь такой url: <tt>"/documents/7/notes/101"</tt>
    </p>

    <p id="Model-urlRoot">
      <b class="header">urlRoot</b><code>model.urlRoot или model.urlRoot()</code>
      <br />
      Укажите <tt>urlRoot</tt>, если вы используете модель вне коллекции,
      чтобы дефолтный метод <a href="#Model-url">url</a> генерировал
      URL'ы, исходя из id. <tt>"/[urlRoot]/id"</tt><br />
      Обратите внимание, что <tt>urlRoot</tt> так же может быть функцией.
    </p>

<pre class="runnable">
var Book = Backbone.Model.extend({urlRoot : '/books'});

var solaris = new Book({id: "1083-lem-solaris"});

alert(solaris.url());
</pre>

    <p id="Model-parse">
      <b class="header">parse</b><code>model.parse(response)</code>
      <br />
      Метод <b>parse</b> вызывается каждый раз, когда данные модели возвращаются
	    сервером, в методах <a href="#Model-fetch">fetch</a> и <a href="#Model-save">save</a>.
      Функции передается «сырой» объект <tt>response</tt>, и она должна возвратить
      хэш атрибутов, который будет передан методу <a href="#Model-set">set</a>. 
      Реализация по умолчанию просто пробрасывает JSON-ответ.
      Переопределите этот метод, если вы работает с уже существующим API,
  	  или чтобы лучше заворачивать в пространства имен ответы сервера.
    </p>

    <p>
      Если вы работаете с Rails, вы наткнетесь на то, что реализация по умолчанию
      <tt>to_json</tt> отдает атрибуты модели в пространстве имен.
	    Чтобы устранить это поведение для лучшей интеграции с Backbone, установите:
    </p>

<pre>
ActiveRecord::Base.include_root_in_json = false
</pre>

    <p id="Model-clone">
      <b class="header">clone</b><code>model.clone()</code>
      <br />
      Возвращает новый экземпляр модели с идентичными атрибутами.
    </p>

    <p id="Model-isNew">
      <b class="header">isNew</b><code>model.isNew()</code>
      <br />
      Была ли модель уже сохранена на сервер? Модель считается новой, 
      если еще не имеет атрибута <tt>id</tt>.
    </p>

    <p id="Model-change">
      <b class="header">change</b><code>model.change()</code>
      <br />
      Ручной запуск событий <tt>"change"</tt> и <tt>"change:attribute"</tt>
      для каждого измененного атрибута. Если вы передавали
      <tt>{silent: true}</tt> в <a href="#Model-set">set</a>, чтобы собрать 
      быстро следующие друг за другом изменения модели, в конце нужно вызвать 
      <tt>model.change()</tt>.
    </p>

    <p id="Model-hasChanged">
      <b class="header">hasChanged</b><code>model.hasChanged([attribute])</code>
      <br />
      Была ли модель изменена с последнего события <tt>"change"</tt>? Если передан <b>attribute</b>,
      возвращает <tt>true</tt>, если этот атрибут был изменен.
    </p>

    <p class="warning">
      Обратите внимание, что этот метод, и следуюшие, касающиеся изменений, полезны только во время
  	  обработки события <tt>"change"</tt>.
    </p>

<pre>
book.on("change", function() {
  if (book.hasChanged("title")) {
    ...
  }
});
</pre>

    <p id="Model-changedAttributes">
      <b class="header">changedAttributes</b><code>model.changedAttributes([attributes])</code>
      <br />
      Возвращает хэш только тех атрибутов модели, которые были изменены.
  	  Опционально может быть передан внешний хэш атрибутов; в этом случае возвращаются
  	  те атрибуты из этого хэша, которые отличаются от таковых в модели.
  	  Может быть полезно для выяснения, какие части представения надо обновить,
	    или какие вызовы надо сделать, чтобы синхронизировать изменения с сервером.
    </p>

    <p id="Model-previous">
      <b class="header">previous</b><code>model.previous(attribute)</code>
      <br />
      Во время события <tt>"change"</tt>, этот метод позволяет получить предыдущее значение измененного атрибута.
    </p>

<pre class="runnable">
var bill = new Backbone.Model({
  name: "Иван Петров"
});

bill.on("change:name", function(model, name) {
  alert("Изменено имя с " + bill.previous("name") + " на " + name);
});

bill.set({name : "Иван Иванов"});
</pre>

    <p id="Model-previousAttributes">
      <b class="header">previousAttributes</b><code>model.previousAttributes()</code>
      <br />
      Возвращает копию предыдущих атрибутов модели. Полезно, чтобы получить
	    diff между версиями модели, или вернуться в валидное состояние после ошибки.
    </p>

    <h2 id="Collection">Backbone.Collection</h2>

    <p>
      Коллекции — это упорядоченные наборы моделей. Вы можете навесить слушатели — 
      на событие <tt>"change"</tt>, чтобы получать оповещения, когда любая модель в коллекции изменяется;
      на события <tt>"add"</tt> и <tt>"remove"</tt>;
      на получение (<tt>fetch</tt>) коллекции с сервера, и использовать полный набор
      <a href="#Collection-Underscore-Methods">методов Underscore.js</a>.
    </p>

    <p>
      Любое событие, которое сработает на модели в коллекции также сработает и напрямую — для удобства — на коллекции.
      Это позволяет напрямую слушать события изменения отдельных атрибутов любой модели в коллекции. Например:
      <tt>Documents.on("change:selected", ...)</tt>
    </p>

    <p id="Collection-extend">
      <b class="header">extend</b><code>Backbone.Collection.extend(properties, [classProperties])</code>
      <br />
      Чтобы создать собственный класс коллекции, расширьте <b>Backbone.Collection</b>,
      предоставив свойства экземпляра в хэше <b>properties</b>, и опциональные свойства класса в <b>classProperties</b>,
      которые станут свойствами функции-конструктора.
    </p>

    <p id="Collection-model">
      <b class="header">model</b><code>collection.model</code>
      <br />
      Переопределите это свойство, чтобы указать класс моделей, которые будет содержать эта коллекция.
      Если это свойство определено, можно передавать «сырые» хэши объектов (и массивы) в методы
      <a href="#Collection-add">add</a>, <a href="#Collection-create">create</a>,
      и <a href="#Collection-reset">reset</a>, и атрибуты будут сконвертированы в модели соответствующего типа.
    </p>

<pre>
var Library = Backbone.Collection.extend({
  model: Book
});
</pre>

    <p id="Collection-constructor">
      <b class="header">constructor / initialize</b><code>new Collection([models], [options])</code>
      <br />
      При создании экземпляра коллекции можно передать начальный массив моделей (в параметре <b>models</b>).
      В <b>options</b> может быть передана функция <a href="#Collection-comparator">функция-компаратор</a>.
      Метод <b>initialize</b> вызывается после создания экземпляра коллекции.
    </p>

<pre>
var tabs = new TabSet([tab1, tab2, tab3]);
</pre>

    <p id="Collection-models">
      <b class="header">models</b><code>collection.models</code>
      <br />
      Прямой доступ к массиву моделей коллекции. Обычно используются методы
      <tt>get</tt>, <tt>at</tt>, или <b>методы Underscore</b>, чтобы получить модели,
      но порой необходима прямая ссылка на массив.
    </p>

    <p id="Collection-toJSON">
      <b class="header">toJSON</b><code>collection.toJSON()</code>
      <br />
      Возвращает массив, содержащий хэш атрибутов каждой модели в коллекции.
      Используется в сериализации и сохранении коллекции целиком.
      Название несколько сбивает с толку потому, что соответствует
      <a href="https://developer.mozilla.org/en/JSON#toJSON()_method">JSON API</a>.
    </p>

<pre class="runnable">
var collection = new Backbone.Collection([
  {name: "Тим", age: 5},
  {name: "Ида", age: 26},
  {name: "Роб", age: 55}
]);

alert(JSON.stringify(collection));
</pre>

    <p id="Collection-Underscore-Methods">
      <b class="header">Методы Underscore (28)</b>
      <br />
      Backbone проксирует методы <b>Underscore.js</b>, чтобы предоставить 
      доступ к 28 функциям, итерирующим по <b>Backbone.Collection</b>.
      Они не все документированы здесь; см. <a href="http://underscorejs.ru/">документацию Underscore</a>.
    </p>

    <ul class="small">
      <li><a href="http://documentcloud.github.com/underscore/#each">forEach (each)</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#map">map</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#reduce">reduce (foldl, inject)</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#reduceRight">reduceRight (foldr)</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#detect">find (detect)</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#select">filter (select)</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#reject">reject</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#all">every (all)</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#any">some (any)</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#include">include</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#invoke">invoke</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#max">max</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#min">min</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#sortBy">sortBy</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#groupBy">groupBy</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#sortedIndex">sortedIndex</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#shuffle">shuffle</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#toArray">toArray</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#size">size</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#first">first</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#initial">initial</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#rest">rest</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#last">last</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#without">without</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#indexOf">indexOf</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#lastIndexOf">lastIndexOf</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#isEmpty">isEmpty</a></li>
      <li><a href="http://documentcloud.github.com/underscore/#chain">chain</a></li>
    </ul>

<pre>
Books.each(function(book) {
  book.publish();
});

var titles = Books.map(function(book) {
  return book.get("title");
});

var publishedBooks = Books.filter(function(book) {
  return book.get("published") === true;
});

var alphabetical = Books.sortBy(function(book) {
  return book.author.get("name").toLowerCase();
});
</pre>

    <p id="Collection-add">
      <b class="header">add</b><code>collection.add(models, [options])</code>
      <br />
      Добавляет модель (или массив моделей) в коллекцию. Запускает событие <tt>"add"</tt>
      которое вы можете подавить наличием ключа <tt>silent</tt> в хэше <b>options</b>.
      Если свойство <a href="#Collection-model">model</a> определено, можно передавать «сырые» атрибуты,
      и они будут оживлены в экземпляры моделей.
      Чтобы вставить модель по специфичному индексу, передайте <tt>{at: index}</tt>.
      Если есть обработчик события <tt>"add"</tt>,
      в него будет передан индекс, под которым была вставлена модель — в параметре <tt>options.index</tt>.
    </p>

<pre class="runnable">
var ships = new Backbone.Collection;

ships.on("add", function(ship) {
  alert("«" + ship.get("name") + "» прямо по курсу!");
});

ships.add([
  {name: "Летучий Голландец"},
  {name: "Черная жемчужина"}
]);
</pre>

    <p id="Collection-remove">
      <b class="header">remove</b><code>collection.remove(models, [options])</code>
      <br />
      Удаляет модель (или массив моделей) из коллекции. Запускает событие <tt>"remove"</tt>
      которое вы можете подавить наличием ключа <tt>silent</tt> в хэше <b>options</b>.
      Если есть обработчик события <tt>"remove"</tt>,
      в него будет передан индекс, под которым находилась удаленная модель — в параметре <tt>options.index</tt>.
    </p>

    <p id="Collection-get">
      <b class="header">get</b><code>collection.get(id)</code>
      <br />
      Возвращает модель из коллекции по ее <b>id</b>.
    </p>

<pre>
var book = Library.get(110);
</pre>

    <p id="Collection-getByCid">
      <b class="header">getByCid</b><code>collection.getByCid(cid)</code>
      <br />
      Возвращает модель из коллекции по указанному cid (свойство <tt>.cid</tt>).
      Это свойство модели автоматически назначается ей при создании. Находит применение для моделей,
      которые еще не были сохранены на сервер и еще не имеют настоящего <tt>id</tt>.
    </p>

    <p id="Collection-at">
      <b class="header">at</b><code>collection.at(index)</code>
      <br />
      Возвращает модель из коллекции по индексу. Полезно, если ваша коллекция отсортирована;
      если нет, то этот метод возвращает модели по порядку вставки.
    </p>

    <p id="Collection-push">
      <b class="header">push</b><code>collection.push(model, [options])</code>
      <br />
      Добавляет модель в конец коллекции. Принимает те же аргументы,
      что и <a href="#Collection-add">add</a>.
    </p>

    <p id="Collection-pop">
      <b class="header">pop</b><code>collection.pop([options])</code>
      <br />
      Удаляет последнюю модель из коллекции и возвращает ее. Принимает те же аргументы,
      что и <a href="#Collection-remove">remove</a>.
    </p>

    <p id="Collection-unshift">
      <b class="header">unshift</b><code>collection.unshift(model, [options])</code>
      <br />
      Добавляет модель в начало коллекции. Принимает те же аргументы,
      что и <a href="#Collection-add">add</a>.
    </p>

    <p id="Collection-shift">
      <b class="header">shift</b><code>collection.shift([options])</code>
      <br />
      Удаляет первую модель из коллекции и возвращает ее. Принимает те же аргументы,
      что и <a href="#Collection-remove">remove</a>.
    </p>

    <p id="Collection-length">
      <b class="header">length</b><code>collection.length</code>
      <br />
      Подобно массивам, коллекции поддерживают свойство <tt>length</tt>,
      равное количеству моделей, которые они содержат.
    </p>

    <p id="Collection-comparator">
      <b class="header">comparator</b><code>collection.comparator</code>
      <br />
      По умолчанию коллекции не определяют функцию-компаратор.
      Если вы определяет компаратор, он будет использован, чтобы поддерживать
      коллекцию в отсортированном виде. Это означает, что когда модели добавляются,
      они вставляются по корректному индексу в <tt>collection.models</tt>.
      <tt>comparator</tt> может быть определен либо как функция, подходящяя для
      <a href="http://underscorejs.org/#sortBy">sortBy из Underscore</a>
      (функция одного аргумента),  либо как функция, подходящая для
      <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort">Array.sort</a>
      (функция двух аргументов).
    </p>

    <p>
      Компараторы типа "sortBy" принимают модель и возвращают численное или строковое
      значение, по которому модель должна быть отсортирована относительно других.
      Компараторы типа "sort" принимают две модели, и должны возвращать: <tt>-1</tt>, если
      перва модель должна идти перед второй; <tt>0</tt>, если у них одинаковая позиция;
      и <tt>1</tt>, если перая модель должна идти после второй.
    </p>

    <p>
      Отметьте, что хотя главы в данном примере добавляются в обратном порядке,
      в коллекции они расположены в верном порядке:
    </p>

<pre class="runnable">
var Chapter  = Backbone.Model;
var chapters = new Backbone.Collection;

chapters.comparator = function(chapter) {
  return chapter.get("page");
};

chapters.add(new Chapter({page: 9, title: "Конец"}));
chapters.add(new Chapter({page: 5, title: "Середина"}));
chapters.add(new Chapter({page: 1, title: "Начало"}));

alert(chapters.pluck('title'));
</pre>

    <p class="warning">
      Коллекции с компаратором не будут автоматически пересортировываться, если
      вы измените атрибуты моделей, которые влияют на сортировку. В этом случае следует
      вызвать <tt>sort</tt> вручную.
    </p>

    <p id="Collection-sort">
      <b class="header">sort</b><code>collection.sort([options])</code>
      <br />
      Заставляет модель выполнить пересортировку. Обычно нет необходимости вызывать этот метод вручную,
      так как коллекции с <a href="#Collection-comparator">компаратором</a> всегда сами будут поддерживать себя в
      отсортированном виде.
      Вызов <b>sort</b> запускает на коллекции событие <tt>"reset"</tt> если не подавить его с помощью <tt>{silent: true}</tt>
    </p>

    <p id="Collection-pluck">
      <b class="header">pluck</b><code>collection.pluck(attribute)</code>
      <br />
      Собирает значения атрибута из каждой модели в коллекции. Эквивалентно вызову
      <tt>map</tt> с возвратом одного атрибута из итератора.
    </p>

<pre class="runnable">
var stooges = new Backbone.Collection([
  {name: "Curly"},
  {name: "Larry"},
  {name: "Moe"}
]);

var names = stooges.pluck("name");

alert(JSON.stringify(names));
</pre>

    <p id="Collection-where">
      <b class="header">where</b><code>collection.where(attributes)</code>
      <br />
      Возвращает массив всех моделей, подходящих под переданный хэш <b>attributes</b>.
      Полезно для простой фильтрации.
    </p>

<pre class="runnable">
var friends = new Backbone.Collection([
  {name: "Атос",       job: "Мушкетер"},
  {name: "Портос",     job: "Мушкетер"},
  {name: "Арамис",     job: "Мушкетер"},
  {name: "д'Артаньян", job: "Гвардеец короля"},
]);

var musketeers = friends.where({job: "Мушкетер"});

alert(musketeers.length);
</pre>

    <p id="Collection-url">
      <b class="header">url</b><code>collection.url или collection.url()</code>
      <br />
      Свойство (или функция) <b>url</b> предназначена для того чтобы указывать положение
      коллекции на сервере. Модели в коллекциях с определенным <b>url</b>
      будут использовать его, чтобы конструировать свои собственные URL'ы.
    </p>

<pre>
var Notes = Backbone.Collection.extend({
  url: '/notes'
});

// Или чуть сложнее:

var Notes = Backbone.Collection.extend({
  url: function() {
    return this.document.url() + '/notes';
  }
});
</pre>

    <p id="Collection-parse">
      <b class="header">parse</b><code>collection.parse(response)</code>
      <br />
      <b>parse</b> вызывается каждый раз, когда модели коллекции
      приходят с сервера, в методе <a href="#Collection-fetch">fetch</a>.
      Функции принимает «сырой» объект <tt>response</tt>, и должна вернуть
      массив атрибутов моделей, которые будут добавлены в коллекцию
      методом <a href="#Collection-add">add</a>. Реализация по умолчанию
      просто пробрасывает JSON-ответ.
      Переопределите этот метод, если вы работает с уже существующим API,
      или чтобы лучше заворачивать в пространства имен ответы сервера.
      Следует отметить, что после этого, если у модели тоже есть метод <tt>parse</tt>,
      он будет вызван на каждой полученной модели.
    </p>

<pre>
var Tweets = Backbone.Collection.extend({
  // API поиска Twitter возвращает твиты в поле "results".
  parse: function(response) {
    return response.results;
  }
});
</pre>

    <p id="Collection-fetch">
      <b class="header">fetch</b><code>collection.fetch([options])</code>
      <br />
      Получает дефолтный набор моделей для этой коллекции с сервера,
      вызывая по их прибытии <tt>reset</tt>. В хэш <b>options</b> могут быть коллбэки
      <tt>success</tt> и <tt>error</tt>, которым передаются коллекция и ответ сервера
      <tt>(collection, response)</tt> в качестве аргументов.
      Когда данные моделей придут с сервера, коллекция вызовет метод
      <a href="#Collection-reset">reset</a>.
      Внутри <tt>fetch</tt> обращается к <a href="#Sync">Backbone.sync</a>
      чтобы можно было создать свою стратегию персистентности, и возвращает
      <a href="http://api.jquery.com/jQuery.ajax/#jqXHR">jqXHR</a>-объект.
      Серверный обрабтчик запросов <b>fetch</b> должен возвращать JSON-массив моделей.
    </p>

<pre class="runnable">
Backbone.sync = function(method, model) {
  alert(method + ": " + model.url);
};

var Accounts = new Backbone.Collection;
Accounts.url = '/accounts';

Accounts.fetch();
</pre>

    <p>
      Можно не заменять, а добавить пришедшие модели в коллекцию, передав
      <tt>{add: true}</tt> в хэше <tt>options</tt>.
    </p>

    <p>
      Опции <b>jQuery.ajax</b> также могут быть напрямую переданы в <b>fetch</b>,
      чтобы, например, получить определенную страницу пагинированной коллекции:
      <tt>Documents.fetch({data: {page: 3}})</tt>
    </p>

    <p>
      Заметьте, что <b>fetch</b> не должен использоваться, чтобы наполнять коллекции на этапе
      загрузки страницы — все модели, необходимые во время загрузки должны быть
      <a href="#FAQ-bootstrap">предзагружены</a>. <b>fetch</b> предназначен
      для «ленивой» загрузки моделей для интерфейсов, которые не нужны
      немедленно: например, документы с коллекциями заметок, которые могут быть открыты или закрыты.
    </p>

    <p id="Collection-reset">
      <b class="header">reset</b><code>collection.reset(models, [options])</code>
      <br />
      Добавлять и удалять модели по одной — хорошо и правильно, но иногда
      надо изменить столько моделей, что проще обновить коллекцию целиком.
      Используйте <b>reset</b>, чтобы заменить коллекцию новым массивом моделей
      (или хэшей атрибутов). При этом сработает одно событие <tt>"reset"</tt>
      в конце. Передайте <tt>{silent: true}</tt>, чтобы подавить его.
      Вызов <b>reset</b> без аргументов — удобный способ опустошить коллекцию.
    </p>

    <p>
      Вот пример использования <b>reset</b> для предзагрузки коллекции в приложении на Rails:
    </p>

<pre>
&lt;script&gt;
  var Accounts = new Backbone.Collection;
  Accounts.reset(&lt;%= @accounts.to_json %&gt;);
&lt;/script&gt;
</pre>

    <p>
      Вызов <tt>collection.reset()</tt> без передачи каких-либо моделей сделает коллекцию пустой.
    </p>

    <p id="Collection-create">
      <b class="header">create</b><code>collection.create(attributes, [options])</code>
      <br />
      Удобное создание модели внутри коллекции.
      Эквивалентно созданию экземпляра модели с хэшом <b>attributes</b>,
      сохранению модели на сервер, и добавлению модели в набор после успешного создания.
      Возвращает модель или <tt>false</tt>, если ошибка валидации не позволила
      модели создасться.
      Для корректной работы у коллекции должно быть свойство <a href="#Collection-model">model</a>.
      Метод <b>create</b> может принимать либо хэш атрибутов, либо существующую несохраненную модель.
    </p>

    <p>
      Создание модели немедленно и автоматически запускает событие <tt>"add"</tt>,
      и событие <tt>"sync"</tt>, как только модель успешно создастся на сервере.
      Передайте <tt>{wait: true}</tt>, если вы хотите подождать ответа сервера перед добавлением.
    </p>

<pre>
var Library = Backbone.Collection.extend({
  model: Book
});

var NYPL = new Library;

var othello = NYPL.create({
  title: "Отелло",
  author: "Вильям Шекспир"
});
</pre>

    <h2 id="Router">Backbone.Router</h2>

    <p>
      Веб-приложения часто предоставляют возможность
      зафиксировать свое состояние, сделав закладку. Это делается с помощью добавления
      к URL фрагмента определенного вида. 
      До недавнего времени, для этих целей использовались исключительно хэши (<tt>#page</tt>),
      но с появлением History API стало возможно использовать URL обычного вида (<tt>/page</tt>).
      <b>Backbone.Router</b> предоставляет методы для маршрутизации на стороне клиента,
      а также связывания этих действий с событиями. Для браузеров, которые не поддерживают
      History API, Router весьма элегантно проделает тоже самое, используя фрагментарную структуру URL.
    </p>

    <p>
      Во время загрузки страницы, после того, как ваше приложение создаст все необходимые ему
      роутеры, не забудьте вызвать <tt>Backbone.history.start()</tt> или
      <tt>Backbone.history.start({pushState: true})</tt>, чтобы задать начальное состояние приложения.
    </p>

    <p id="Router-extend">
      <b class="header">extend</b><code>Backbone.Router.extend(properties, [classProperties])</code>
      <br />
      Создавая свой класс-маршрутизатор, нужно расширить <b>Backbone.Router</b>. 
      Определите для него actions — действия, которые будут выполнены
      когда часть текущего URL совпадет с заданным фрагментом,
      и предоставьте хэш
      <a href="#Router-routes">роутов (routes)</a>, в котором будут описаны паттерны URL и 
      соответствующие им действия.<br/>
      На заметку: нельзя начинать название роута со слэша.
    </p>

<pre>
var Workspace = Backbone.Router.extend({

  routes: {
    "help":                 "help",    // #help
    "search/:query":        "search",  // #search/kiwis
    "search/:query/p:page": "search"   // #search/kiwis/p7
  },

  help: function() {
    ...
  },

  search: function(query, page) {
    ...
  }

});
</pre>

    <p id="Router-routes">
      <b class="header">routes</b><code>router.routes</code>
      <br />
      Хэш роутов описывает соответствие паттернов URL с функциями вашего роутера
      и их аргументами, аналогично тому, как это происходит с 
      <a href="#View-delegateEvents">хэшем событий</a> <a href="#View">представлений</a>.
      Роут может содержать параметрические части, <tt>:param</tt>, 
      каждая из которых будет соответствовать единственному фрагменту 
      URL между слэшами, и <tt>*splat</tt> части, 
      которые могут соответствовать любому количеству фрагментов URL.
    </p>

    <p>
     	Например, роут "search/:query/p:page" соответствует фрагменту #search/obama/p2 и аргументы obama и p2 
      будут переданы в action. Роут <tt>"file/*path"</tt> соответствует <tt>#file/nested/folder/file.txt</tt> и в action 
      в качестве аргумента будет передана строка <tt>"nested/folder/file.txt"</tt>.
    </p>

    <p>
      Когда пользователь нажимает кнопки «назад/вперед» или вводит в адресную строку URL, который
      сооветствует какому-либо роуту, будет сгенерировано <a href="#Events">событие (event)</a>, одноименное action этого роута,
      таким образом другие объекты тоже могу слушать роутер и «быть в курсе» происходящих событий.
      В приведенном ниже примере посещение <tt>#help/uploading</tt> приведет к тому, что роутер 
      сгенерирует событие <tt>route:help</tt>.
    </p>

<pre>
routes: {
  "help/:page":         "help",
  "download/*path":     "download",
  "folder/:name":       "openFolder",
  "folder/:name-:mode": "openFolder"
}
</pre>

<pre>
router.on("route:help", function(page) {
  ...
});
</pre>

    <p id="Router-constructor">
      <b class="header">constructor / initialize</b><code>new Router([options])</code>
      <br />
      Создавая роутер вы можете задать его роуты, передав их в качестве свойства объекта <tt>options</tt>, 
      если хотите. Кроме того объект <tt>options</tt> целиком будет передан в определенную вами
      функцию <tt>initialize</tt>.
    </p>

    <p id="Router-route">
      <b class="header">route</b><code>router.route(route, name, [callback])</code>
      <br />
      С помощью этого метода можно добавить новый роут к объекту после инициализации.
      Аргумент <tt>route</tt> может быть <a href="#Router-routes">строкой-роутом</a> или регулярным выражением.
      Части URL, соответствующие заданному роуту или регулярному выражению, будут
      переданы функции callback в качестве аргументов. Аргумент <tt>name</tt> будет использован
      для того, чтобы сгенерировать события вида <tt>"route:name"</tt> при совпадении фрагмента URL и роута.
      Если аргумент <tt>callback</tt> опущен, то будет использована <tt>router[name]</tt>.
    </p>

<pre>
initialize: function(options) {

  // совпадает с #page/10, в function будет передано "10"
  this.route("page/:number", "page", function(number){ ... });

  // совпадает с /117-a/b/c/open, в this.open будет передано "117-a/b/c"
  this.route(/^(.*?)\/open$/, "open");

},

open: function(id) { ... }
</pre>

    <p id="Router-navigate">
      <b class="header">navigate</b><code>router.navigate(fragment, [options])</code>
      <br />
      Когда вы решите, что ваше приложение находится в состоянии, которое желательно было бы сохранить,
      вызовите <b>navigate</b> чтобы обновить URL, передав в качестве аргумента <tt>fragment</tt> необходимый фрагмент URL.
      Если при этом вы хотите вызвать функцию роутера, то установите свойство <b>trigger</b>
      в <tt>true</tt>.
      Для того, чтобы обновить URL без создания записи в истории браузера, установите свойство
      <b>replace</b> в <tt>true</tt>.
    </p>

<pre>
openPage: function(pageNumber) {
  this.document.pages.at(pageNumber).open();
  this.navigate("page/" + pageNumber);
}

# или ...

app.navigate("help/troubleshooting", {trigger: true});

# или ...

app.navigate("help/troubleshooting", {trigger: true, replace: true});
</pre>

    <h2 id="History">Backbone.history</h2>

    <p>
      <b>History</b> служит глобальным роутером (в пределах фрейма), обрабатывая события <tt>hashchange</tt>
      или вызовы <tt>pushState</tt>, находя сопоставление с подходящим роутом, и запуская коллбэки.
      Вам не надо даже вручную создавать ничего из этого — используйте ссылку на <tt>Backbone.history</tt>,
      которая будет автоматически создана, если вы воспользуетесь 
      <a href="#Router">Router</a>'ом с определенными в нем <a href="#Router-routes">routes</a>.
    </p>

    <p>
      Поддержка <b>pushState</b> существует в Backbone в сугубо опциональной форме.
      Старые браузеры, которые не поддерживают <tt>pushState</tt> будут продолжать использовать
      хэш-фрагменты адресов, и если поддерживающий <tt>pushState</tt> браузер зайдет на URL с хэшем,
      этот URL будет прозрачно заменен настоящим URL'ом. Отметьте, что использование таких адресов
      требует от веб-сервера корректной отдачи таких страниц, так что могут потребоваться изменения и на сервере.
      Например, если у вас есть роут <tt>/documents/100</tt>,
      ваш сервер должен отдать эту страницу, если браузер зайдет на нее напрямую.
      Для полной индексации поисковиками лучше всего, если сервер генерирует полный HTML 
      для страницы… но если речь идет о веб-приложении, достаточно просто отдавать тот же контент, что 
      и для корневой страницы, и дополнять оставшееся с помощью JS и представлений Backbone.
    </p>

    <p id="History-start">
      <b class="header">start</b><code>Backbone.history.start([options])</code>
      <br />
      Когда созданы все ваши <a href="#Router">роутеры</a> и все роуты корректно
      установлены, вызовите <tt>Backbone.history.start()</tt>
      чтобы начать отслеживать события <tt>hashchange</tt> и диспетчеризовать роуты.
    </p>

    <p>
      Чтобы обозначить, что вы хотите использовать поддержку <tt>pushState</tt> из HTML5 
      в вашем приложении, вызовите <tt>Backbone.history.start({pushState: true})</tt>.
    </p>

    <p>
      Если приложение отдается не с корневого адреса (<tt>/</tt>)
      домена, обязательно укажите History, где находится корень, с помощью опции:
      <tt>Backbone.history.start({pushState: true, root: "/public/search/"})</tt>
    </p>

    <p>
      Во время вызова, если в роутах находится соответствие с текущим адресом,
      <tt>Backbone.history.start()</tt> возвращает <tt>true</tt>. Если ни один 
      из существующих роутов не подходит к текущему адресу, будет возвращено значение <tt>false</tt>.
    </p>

    <p>
      Если сервер уже отрисовал всю страницу, и вы не хотите, чтобы начальный роут сработал, 
      когда стартует History, передайте <tt>silent: true</tt>.
    </p>

    <p>
      Так как хэш-навигация в IE полагается на <tt>&lt;iframe&gt;</tt>,
      вызывайте <tt>start()</tt> только после готовности DOM.
    </p>

<pre>
$(function(){
  new WorkspaceRouter();
  new HelpPaneRouter();
  Backbone.history.start({pushState: true});
});
</pre>

    <h2 id="Sync">Backbone.sync</h2>

    <p>
      <b>Backbone.sync</b> — функция, которую Backbone вызывает каждый раз, 
      когда пытается прочитать/сохранить модель с/на сервер. По умолчанию она использует 
      <tt>(jQuery/Zepto).ajax</tt>, чтобы делать RESTful JSON-запросы и возвращает
      <a href="http://api.jquery.com/jQuery.ajax/#jqXHR">jqXHR</a>. Ее можно переопределить, чтобы 
      использовать другую стратегию персистентности — WebSocket'ы,
      XML транспорт, или localStorage.
    </p>

    <p>
      Сигнатура метода — <tt>sync(method, model, [options])</tt>
    </p>

    <ul>
      <li><b>method</b> – метод CRUD (<tt>"create"</tt>, <tt>"read"</tt>, <tt>"update"</tt>, or <tt>"delete"</tt>)</li>
      <li><b>model</b> – модель для сохранения (или коллекция для чтения)</li>
      <li><b>options</b> – коллбэки <tt>success<tt/> и <tt>error</tt> на успех и на ошибку,
      и любые другие опции, которые принимает jQuery.ajax.</li>
    </ul>

    <p>
      В реализации по умолчанию, когда <b>Backbone.sync</b> посылает запрос на сохранение
      модели, её атрибуты будут переданы, сериализованные как JSON, и посланы в теле HTTP
      с контент-типом <tt>application/json</tt>. Возвращая JSON-ответ,
      посылайте атрибуты модели, которые были изменены сервером, и должны быть 
      обновлены на клиенте. Отвечая на запрос <tt>"read"</tt> от коллекции
      (<a href="#Collection#fetch">Collection#fetch</a>), посылайте массив 
      атрибутов моделей.
    </p>

    <p>
      Функция <b>sync</b> может быть переопределена глобально как <tt>Backbone.sync</tt>,
      или на более тонком уровне, добавлением метода <tt>sync</tt> в коллекцию Backbone
      или в отдельную модель.
    </p>

    <p>
      Обработчик <b>sync</b> по умолчанию мапит CRUD в REST таким образом:
    </p>

    <ul>
      <li><b>create &rarr; POST &nbsp; </b><tt>/collection</tt></li>
      <li><b>read &rarr; GET &nbsp; </b><tt>/collection[/id]</tt></li>
      <li><b>update &rarr; PUT &nbsp; </b><tt>/collection/id</tt></li>
      <li><b>delete &rarr; DELETE &nbsp; </b><tt>/collection/id</tt></li>
    </ul>

    <p>
      Для примера, обработчик в Rails, отвечающий на вызов <tt>"update"</tt> из
      <tt>Backbone</tt> может выглядеть так: <i>(В настоящем коде никогда не используйте 
      </i><tt>update_attributes</tt><i> слепо, и всегда перечисляйте атрибуты, 
      разрешенные к изменению, с помощью «белого списка».)</i>
    </p>

<pre>
def update
  account = Account.find params[:id]
  account.update_attributes params
  render :json => account
end
</pre>

    <p>
      Еще один совет по интеграции с Rails  — отключить заворачивание в пространство имен для 
      вызовов <tt>to_json</tt> на моделях, установив <tt>ActiveRecord::Base.include_root_in_json = false</tt>
    </p>

    <p id="Sync-emulateHTTP">
      <b class="header">emulateHTTP</b><code>Backbone.emulateHTTP = true</code>
      <br />
      Если необходимо работать со старым сервером, который не поддерживает подход 
      по умолчанию REST/HTTP, можно включить эмуляцию HTTP-глаголов <tt>Backbone.emulateHTTP</tt>.
      Установка этой опции будет подделывать <tt>PUT</tt> и <tt>DELETE</tt> запросы 
      с помощью HTTP <tt>POST</tt>, устанавливая заголовок <tt>X-HTTP-Method-Override</tt> 
      в настоящий метод. Если опция <tt>emulateJSON</tt> также включена, 
      настоящий метод будет передан, как дополнительный параметр <tt>_method</tt>.
    </p>

<pre>
Backbone.emulateHTTP = true;

model.save();  // POST to "/collection/id", with "_method=PUT" + header.
</pre>

    <p id="Sync-emulateJSON">
      <b class="header">emulateJSON</b><code>Backbone.emulateJSON = true</code>
      <br />
      Если необходимо работать со старым сервером, который не может обрабатывать 
      запросы, закодированные как <tt>application/json</tt>, выставление <tt>Backbone.emulateJSON = true;</tt>
      заставит JSON сериализоваться в параметр <tt>model</tt>, и запрос будет сделан
      с mime-типом <tt>application/x-www-form-urlencoded</tt>, как если бы это была HTML-форма.
    </p>

    <h2 id="View">Backbone.View</h2>

    <p>
      Представления в Backbone — это скорее соглашение, нежели код: они никак не влияют
      на ваш HTML и CSS, и могут быть использованы с любой шаблонной библиотекой.
      Основная идея — организовать ваш интерфейс в логически выделенные представления,
      опирающиеся на модели, каждая из которых может быть обновлена независимо, когда
      модель изменяется, без необходимости перерисовать страницу. Вместо того, чтобы копаться
      в JSON-объекте, выискивать элемент в DOM-дереве, и обновлять HTML вручную,
      вы привязываете метод <tt>render</tt> представления к событию <tt>"change"</tt> модели —
      и теперь везде, где бы ни отображались данные модели, они немедленно становятся актуальными.
    </p>

    <p id="View-extend">
      <b class="header">extend</b><code>Backbone.View.extend(properties, [classProperties])</code>
      <br />
      Создание своего класса представления. Нужно переопределить метод <a href="#View-render">render</a>,
      декларативно указать <a href="#View-delegateEvents">события</a>, и, возможно,
      <tt>tagName</tt>, <tt>className</tt>, или <tt>id</tt> корневого элемента представления.
    </p>

<pre>
var DocumentRow = Backbone.View.extend({

  tagName: "li",

  className: "document-row",

  events: {
    "click .icon":          "open",
    "click .button.edit":   "openEditDialog",
    "click .button.delete": "destroy"
  },

  render: function() {
    ...
  }

});
</pre>

    <p id="View-constructor">
      <b class="header">constructor / initialize</b><code>new View([options])</code>
      <br />
      При создании экземпляра представления, опции которые вы передаете в хэше <b>options</b>
      будут доступны как <tt>this.options</tt> внутри него. Есть несколько особенных опций,
      которые, будучи переданы, будут доступны как прямые свойства представления:
      <tt>model</tt>, <tt>collection</tt>,
      <tt>el</tt>, <tt>id</tt>, <tt>className</tt>, <tt>tagName</tt> и <tt>attributes</tt>.
      Если представление определяет метод <b>initialize</b>, он будет вызван
      в момент создания экземпляра. Если вы хотите создать представление, которое
      ссылается на элемент, <i>уже присутствующий</i> в DOM, передайте его в опциях:
      <tt>new View({el: existingElement})</tt>. В дальнейшем он так же будет доступен как <tt>this.el</tt>
    </p>

<pre>
var doc = Documents.first();

new DocumentRow({
  model: doc,
  id: "document-row-" + doc.id
});
</pre>

    <p id="View-el">
      <b class="header">el</b><code>view.el</code>
      <br />
      Все представления всегда имеют DOM-элемент в любой момент времени (свойство <b>el</b>),
      вставлены они в документ или нет. Таким образом представления могут быть отрендерены в любое время,
      и вставлены в DOM-дерево все разом — это приводит к высокопроизводительному интерфейсу
      с как можно меньшим количеством переформатирований и перерисовываний (reflows and repaints)
      <tt>this.el</tt> создается из свойств <tt>tagName</tt>, <tt>className</tt>, <tt>id</tt> и <tt>attributes</tt>,
      если они указаны. Если нет — <b>el</b> будет пустым <tt>div</tt>'ом.
    </p>

<pre class="runnable">
var ItemView = Backbone.View.extend({
  tagName: 'li'
});

var BodyView = Backbone.View.extend({
  el: 'body'
});

var item = new ItemView();
var body = new BodyView();

alert(item.el + ' ' + body.el);
</pre>

    <p id="View-$el">
      <b class="header">$el</b><code>view.$el</code>
      <br />
      Закешированный объект jQuery (или Zepto) c элементом данного представления — то же самое, что <tt>$(this.el)</tt>.
      Удобная ссылка — замена постоянному оборачиванию DOM-элемента.
    </p>

<pre>
view.$el.show();

listView.$el.append(itemView.el);
</pre>

    <p id="View-setElement">
      <b class="header">setElement</b><code>view.setElement(element)</code>
      <br />
      Если вы хотите применить Backbone-представление к другому DOM-элементу, используйте
      <b>setElement</b>, который также создаст закешированную ссылку <tt>$el</tt>
      и перенесет делегированные события со старого элемента на новый.
    </p>

    <p id="View-attributes">
      <b class="header">attributes</b><code>view.attributes</code>
      <br />
      Хэш атрибутов, которые будут установлены DOM-элементу <tt>el</tt> (id, класс, data-атрибуты, и т.д.),
      или функция, которая возвращает такой хэш.
    </p>

    <p id="View-dollar">
      <b class="header">$ (jQuery or Zepto)</b><code>view.$(selector)</code>
      <br />
      Если jQuery или Zepto подключены на странице, каждое представление имеет
      функцию <b>$</b>, которая выполняет DOM-запросы внутри элемента представления.
      Используя эту функцию, вы не нуждаетесь в использовании id модели как части вашего запроса чтобы
      получить определенные элементы в списке, и можете полагаться на HTML-класс.
      Это эквивалентно такому вызову: <tt>view.$el.find(selector)</tt>
    </p>

<pre>
ui.Chapter = Backbone.View.extend({
  serialize : function() {
    return {
      title: this.$(".title").text(),
      start: this.$(".start-page").text(),
      end:   this.$(".end-page").text()
    };
  }
});
</pre>

    <p id="View-render">
      <b class="header">render</b><code>view.render()</code>
      <br />
      Метод <b>render</b> по умолчанию реализован как пустая функция. Переопределите её
      своим кодом отрисовки шаблона с данными модели и обновления <tt>this.el</tt> новым HTML.
      Хорошее соглашение — делать <tt>return this</tt> в конце <b>render</b>, чтобы иметь возможность
      делать цепочечные вызовы.
    </p>

<pre>
var Bookmark = Backbone.View.extend({
  render: function() {
    $(this.el).html(this.template(this.model.toJSON()));
    return this;
  }
});
</pre>

    <p>
      Backbone ничего не знает о ваших предпочтениях создания HTML.
      Ваш метод <b>render</b> может просто конкатенировать HTML-строку, или использовать
      <tt>document.createElement</tt>, чтобы генерировать DOM-дерево. Как бы то ни было, мы предлагаем
      выбрать хорошую шаблонную библиотеку.
      <a href="http://github.com/janl/mustache.js">Mustache.js</a>,
      <a href="http://github.com/creationix/haml-js">Haml-js</a>, и
      <a href="http://github.com/sstephenson/eco">Eco</a> являются хорошими альтернативами.
      Так как на странице уже присутствует <a href="http://documentcloud.github.com/underscore/">Underscore.js</a>,
      доступна функция <a href="http://documentcloud.github.com/underscore/#template">_.template</a>
      и является превосходным выбором, если вы уже санитировали свои данные от XSS.
    </p>

    <p>
      На какой бы стратегии шаблонизации вы бы не остановились, она хороша, если вы <i>никогда</i>
      не помещаете строки с HTML в ваш JavaScript. В DocumentCloud мы используем
      <a href="http://documentcloud.github.com/jammit/">Jammit</a> чтобы упаковать
      наши JS-шаблоны, хранящиеся в <tt>/app/views</tt>, как часть нашего
      главного пакета ассетов, в <tt>core.js</tt>.
    </p>

    <p id="View-remove">
      <b class="header">remove</b><code>view.remove()</code>
      <br />
      Удобная функция для удаления элемента представления из DOM. Эквивалентно вызову
      <tt>$(view.el).remove();</tt>
    </p>

    <p id="View-make">
      <b class="header">make</b><code>view.make(tagName, [attributes], [content])</code>
      <br />
      Удобная функция для создания DOM-элемента данного типа (<b>tagName</b>),
      с опциональными атрибутами и HTML-содержимым <b>content</b>. Используется «под капотом»,
      чтобы создать начальный <tt>view.el</tt>.
    </p>

<pre class="runnable">
var view = new Backbone.View;

var el = view.make("b", {"class": "bold"}, "Жырнота! ");

$("#make-demo").append(el);
</pre>

<div id="make-demo"></div>

    <p id="View-delegateEvents">
      <b class="header">delegateEvents</b><code>delegateEvents([events])</code>
      <br />
      Использует функцию <tt>delegate</tt> из jQuery для декларативного описания обработчиков DOM-событий
      внутри представления.
      Если хэш <b>events</b> не передан явно, используется <tt>this.events</tt>.
      События записываются в следующем формате <tt>{"событие селектор": "обработчик"}</tt>.
      Обработчик может быть как именем метода представления, так и напрямую функцией.
      Если опустить <tt>селектор</tt>, то событие будет привязано к корневому элементу представления.
      (<tt>this.el</tt>). По умолчанию <tt>delegateEvents</tt> вызывается внутри конструктора за вас,
      так что если ваш хэш <tt>events</tt> прост, все ваши DOM-события уже будут снабжены обработчиками,
      и вам не придется вызывать этот метод вручную.
    </p>

    <p>
      Свойство <tt>events</tt> может так же быть определено как функция, которая
      возвращает соответствующий хэш, чтобы было проще программно описать ваши
      события, так же как и унаследовать их от родительского преставления.
    </p>

    <p>
      Использование <b>delegateEvents</b> предоставляет несколько преимуществ перед ручным
      навешиванием обработчиков с помощью jQuery во время <a href="#View-render">рендеринга</a>. Все присоединенные
      коллбэки привязываются к представлению перед передачей их в jQuery, так что при их вызове
      <tt>this</tt> продолжает ссылаться на экземпляр представления. Когда
      <b>delegateEvents</b> запускается снова (возможно, с другим хэшем событий)
      все коллбэки удаляются и делегируются заново &mdash; что удобно для представлений,
      которым нужно менять поведение в разных режимах.
    </p>

    <p>
      Представление, которое отображает документ в результатах поиска может
      выглядеть примерно так:
    </p>

<pre>
var DocumentView = Backbone.View.extend({

  events: {
    "dblclick"                : "open",
    "click .icon.doc"         : "select",
    "contextmenu .icon.doc"   : "showMenu",
    "click .show_notes"       : "toggleNotes",
    "click .title .lock"      : "editAccessLevel",
    "mouseover .title .date"  : "showTooltip"
  },

  render: function() {
    $(this.el).html(this.template(this.model.toJSON()));
    return this;
  },

  open: function() {
    window.open(this.model.get("viewer_url"));
  },

  select: function() {
    this.model.set({selected: true});
  },

  ...

});
</pre>

    <p id="View-undelegateEvents">
      <b class="header">undelegateEvents</b><code>undelegateEvents()</code>
      <br />
      Удаляет все делегированные события. Применяется, если нужно временно деактивировать либо
      удалить представление из DOM.
    </p>

    <h2 id="Utility">Utility Functions</h2>

    <p id="Utility-noConflict">
      <b class="header">noConflict</b><code>var backbone = Backbone.noConflict();</code>
      <br />
      Откатывает объект <tt>Backbone</tt> в предыдущее значение. Можно
      использовать возвращенное из <tt>Backbone.noConflict()</tt> значение, чтобы хранить
      ссылку на Backbone. Находит применение при внедрении Backbone на сторонние сайты,
      где вы не хотите испортить существующий Backbone.
    </p>

<pre>
var localBackbone = Backbone.noConflict();
var model = localBackbone.Model.extend(...);
</pre>

    <p id="Utility-setDomLibrary">
      <b class="header">setDomLibrary</b><code>Backbone.setDomLibrary(jQueryNew);</code>
      <br />
      Если у вас несколько копий <tt>jQuery</tt> на странице, или если вы хотите
      приказать Backbone использовать определенный объект в качестве DOM / Ajax библиотеки,
      это функция для вас.
    </p>

    <h2 id="examples">Примеры</h2>

    <p>
      Нижеследующий список примеров крайне неполон, так как мы (переводчики) 
      не хотели переводить длинный список неизвестных в рунете приложений. 
      Если вы используете Backbone в русско-язычном веб-приложении, пожалуйста, дайте нам знать.
      Вы можете взглянуть на <a href="http://backbonejs.org/#examples">оригинальный список примеров</a> или посетить
      <a href="https://github.com/documentcloud/backbone/wiki/Projects-and-Companies-using-Backbone">вики-страницу приложений на Backbone</a>.
    </p>

    <p id="examples-todos">
      <a href="http://jgn.me/">Jérôme Gravel-Niquet</a> создал пример приложения
      <a href="examples/todos/index.html">списков Todo</a>, которое находится в репозитории.
      Если вы не знаете, с чего вообще начать в Backbone, потратьте минутку,
      <a href="docs/todos.html">чтобы прочесть исходный код с аннотациями</a>. Это приложение использует
      <a href="docs/backbone-localstorage.html">адаптер к localStorage</a>, 
      чтобы прозрачно сохранять все ваши todo в браузере, вместо отсылки их на сервер.
      Так же есть версия, расположенная 
      <a href="http://localtodos.com/">localtodos.com</a>, которая использует
      <a href="http://github.com/jeromegn/backbone-mootools">MooTools-базированную версию Backbone</a>
      вместо jQuery.
    </p>

    <div style="text-align: center;">
      <a href="examples/todos/index.html">
        <img src="docs/images/todos.png" alt="Todos" class="example_image" />
      </a>
    </div>

    <h2 id="examples-documentcloud">DocumentCloud</h2>

    <p>
      <a href="http://www.documentcloud.org/public/#search/">Рабочее пространство DocumentCloud</a>
      построено на Backbone.js, и <i>Документы</i>, <i>Проекты</i>,
      <i>Заметки</i>, и <i>Счета</i> — все являются моделями и коллекциями Backbone.
      Если вам интересна история — и Underscore.js и Backbone.js
      были изначально извлечены из кода DocumentCloud codebase, и упакованы, как самостоятельные JS-библиотеки.
    </p>

    <div style="text-align: center;">
      <a href="http://www.documentcloud.org/public/#search/">
        <img src="docs/images/dc-workspace.png" alt="DocumentCloud Workspace" class="example_image" />
      </a>
    </div>

    <h2 id="examples-linkedin">LinkedIn Mobile</h2>

    <p>
      <a href="http://www.linkedin.com/">LinkedIn</a> использует Backbone.js, чтобы создать 
      их <a href="http://www.linkedin.com/static?key=mobile">HTML5 мобильное веб-приложение следующего поколения</a>.
      С Backbone просто сохранять приложение модульным, организованным и расширяемым,
      что сделало возможно запрограммировать сложности UX LinkedIn.
      Приложение так же использует <a href="http://zeptojs.com/">Zepto</a>,
      <a href="http://documentcloud.github.com/underscore/">Underscore.js</a>,
      <a href="http://sass-lang.com/">SASS</a>, <a href="http://cubiq.org/iscroll">iScroll</a>,
      localStorage и сanvas.
    </p>

    <div style="text-align: center;">
      <a href="http://www.linkedin.com/static?key=mobile">
        <img src="docs/images/linkedin-mobile.png" alt="LinkedIn Mobile" class="example_image" />
      </a>
    </div>

    <h2 id="examples-foursquare">Foursquare</h2>

    <p>
      Foursquare — небольшой забавный стартап, который помогает встречаться с друзьями,
      открывать новые места и экономить деньги.
      Модели Backbone широко используются в ядре API, и представления движут многие популярные фичи, 
      как <a href="https://foursquare.com">карта на домашней странице</a> и 
      <a href="https://foursquare.com/seriouseats/list/the-best-doughnuts-in-ny">списки</a>.
    </p>

    <div style="text-align: center;">
      <a href="http://foursquare.com">
        <img src="docs/images/foursquare.png" alt="Foursquare" class="example_image" />
      </a>
    </div>

    <h2 id="examples-khan-academy">Khan Academy</h2>

    <p>
      <a href="http://www.khanacademy.org">Khan Academy</a> выполняет миссию 
      предоставления бесплатного образования мирового уровня всем и везде.
      С тысячью видео, сотнями работающих на JS упражнений, и большими планами на будущее,
      Khan Academy использует Backbone, чтобы хранить фронтенд-код модульным и организованным.
      <a href="https://khanacademy.kilnhg.com/Code/Website/Group/stable/Files/javascript/profile-package?rev=tip">Профили пользователей</a>
      и <a href="https://khanacademy.kilnhg.com/Code/Website/Group/stable/File/javascript/shared-package/goals.js?rev=tip">установка целей</a>
      рализованы с помощью Backbone, <a href="http://jquery.com/">jQuery</a> и <a href="http://handlebarsjs.com/">Handlebars</a>, 
      и большая часть работы по новым фичам сдвигается на клиентскую сторону, сильно увеличивая качество 
      <a href="https://github.com/Khan/khan-api/">API</a>.
    </p>

    <div style="text-align: center;">
      <a href="http://www.khanacademy.org">
        <img src="docs/images/khan-academy.png" alt="Khan Academy" class="example_image" />
      </a>
    </div>

    <h2 id="examples-basecamp">Basecamp Mobile</h2>

    <p>
      <a href="http://37signals.com/">37Signals</a> использовали Backbone.js, чтобы создать
      <a href="http://basecamphq.com/mobile">Basecamp Mobile</a>, мобильную версию 
      их популярного ПО управления проектами. Есть доступ ко всем вашим проектами в Basecamp,
      можно постить новые сообщения и комментировать майлстоны (все они внутри представлены
      как модели Backbone.js).
    </p>

    <div style="text-align: center;">
      <a href="http://basecamphq.com/mobile">
        <img src="docs/images/basecamp-mobile.png" alt="Basecamp Mobile" class="example_image" />
      </a>
    </div>

    <h2 id="faq">F.A.Q.</h2>

    <p id="FAQ-events">
      <b class="header">Каталог событий</b>
      <br />
      Это список всех встроенных событий, которые может запускать Backbone.js.
      Вы так же вольны запускать свои собственные события на моделях и представлениях,
      как считаете нужным.
    </p>

    <ul class="small">
      <li><b>"add"</b> (model, collection) &mdash; кога модель добавляется в коллекцию. </li>
      <li><b>"remove"</b> (model, collection) &mdash; когда модель удаляется из коллекции. </li>
      <li><b>"reset"</b> (collection) &mdash; когда все содержимое коллекции заменяется. </li>
      <li><b>"change"</b> (model, options) &mdash; когда атрибут модели меняется. </li>
      <li><b>"change:[attribute]"</b> (model, value, options) &mdash; когда меняется конкретный атрибут модели. </li>
      <li><b>"destroy"</b> (model, collection) &mdash; когда модель <a href="#Model-destroy">уничтожена</a>. </li>
      <li><b>"sync"</b> (model, collection) &mdash; срабатывает, когда модель была успешно синхронизирована с сервером. </li>
      <li><b>"error"</b> (model, collection) &mdash; когда валидация модели проваливается, или вызов <a href="#Model-save">save</a> проваливается на сервере. </li>
      <li><b>"route:[name]"</b> (router) &mdash; когда один из роутов находит соответствие. </li>
      <li><b>"all"</b> &mdash; это специальное событие срабатывает каждый раз,
      когда срабатывает <i>любое</i> событие, передавая имя события первым аргументом</li>
    </ul>

    <p id="FAQ-tim-toady">
      <b class="header">Больше, чем один, способов сделать это</b>
      <br />
      Часто люди начинают обращаться с примерами, приведенными на этой странице, 
      как с какой-то божественной истиной. На самом деле, Backbone.js предназначен
      быть довольно агностичным насчет многих частых паттернов клиентского кода.
      Например…
    </p>

    <p>
      <b>Отношения между моделями и представлениями</b> могут осуществляться многими способами.
      Некоторым нравится иметь прямые указатели, когда представления соотносятся 1:1 с моделями
      <tt>model.view</tt> и <tt>view.model</tt>). Другие предпочитают иметь промежуточный 
      "контроллер", который дирижирует созданием и организацией представлений в иерархию.
      Другие все еще предпочитают событийный подход, и всегда запускают события вместо 
      прямого вызова методов. Все это прекрасно работает.
    </p>

    <p>
      <b>Групповые операции</b> над моделями часто встречаются, но лучший способ обработки
      зависит от серверной стороны. Некоторых не заботят индивидуальные AJAX-запросы.
      Другие создают явные ресурсы для RESTful групповых операций:
      <tt>/notes/batch/destroy?ids=1,2,3,4</tt>. Третьи туннелируют REST через JSON, созданием 
      запросов "changeset":
    </p>

<pre>
  {
    "create":  [массив моделей для создания]
    "update":  [массив моделей для обновления]
    "destroy": [массив id моделей для уничтожения]
  }
</pre>

    <p>
      <b>Создавайте свой события.</b> <a href="#Events">Backbone.Events</a>
      спроектирован так, что вы можете вмешать его в любой объект или прототип.
      Так как можно использовать любую строку в качестве имени события, часто 
      удобно привязываться и запускать свои собственные события: <tt>model.on("selected:true")</tt> или
      <tt>model.on("editing")</tt>
    </p>

    <p>
      <b>Отрисовывайте UI</b>, как считаете нужным. Backbone ничего не знает о том, 
      используете вы <a href="http://documentcloud.github.com/underscore/#template">шаблоны Underscore</a>,
      <a href="https://github.com/janl/mustache.js">Mustache.js</a>, прямые DOM-манипуляции,
      сгенерированные на сервере кусочки HTML, или <a href="http://jqueryui.com/">jQuery UI</a>
      в методе <tt>render</tt>.
      Иногда вы создаете представление для каждой модели, иногда есть представление,
      которое отображает тысячи моделей разом, в одном цикле. Оба подхода могут 
      подходить в одном приложении, в зависимости от количества данных и сложности UI.
    </p>

    <p id="FAQ-nested">
      <b class="header">Вложенные модели и коллекции</b>
      <br />
      Нередко коллекции вкладываются внутрь моделей в Backbone. Например,
      рассмотрим модель <tt>Mailbox</tt>, которая содержит много моделей <tt>Message</tt>.
      Есть хороший паттерн организации этого всего — иметь коллекцию <tt>this.messages</tt> для
      каждого ящика, делая возможным ленивую загрузку сообщений, когда ящик открывается первый раз…
      возможно, в паре с представлениями <tt>MessageList</tt>, слушающими события
      <tt>"add"</tt> and <tt>"remove"</tt> events.
    </p>

<pre>
var Mailbox = Backbone.Model.extend({

  initialize: function() {
    this.messages = new Messages;
    this.messages.url = '/mailbox/' + this.id + '/messages';
    this.messages.on("reset", this.updateCounts);
  },

  ...

});

var Inbox = new Mailbox;

// И потом, когда Inbox открывается:

Inbox.messages.fetch();
</pre>

    <p>
      Если нужно что-то более строгое — 
      <a href="https://github.com/documentcloud/backbone/wiki/Extensions%2C-Plugins%2C-Resources">существует много плагинов</a>,
      которые добавляют сложные ассоциации между моделями.
    </p>

    <p>
      Backbone не включает прямой поддержки вложенных моделей и коллекций
      или связей "has many", так как существует много хороших паттернов
      моделирования сложных структур на клиенте, и 
      <i>Backbone должен предоставлять фундамент для реализации любого и них.</i>
      Вам может понадобиться&hellip;
    </p>

    <ul>
      <li>
        Отражать структуру SQL БД, или структуру NoSQL БД.
      </li>
      <li>
        Использовать модели с массивами "внешних ключей", и джойнить 
        их в коллекции верхнего уровня (a-la таблицы).
      </li>
      <li>
        Для многочисленных связей использовать диапазоны id вместо явного списка.
      </li>
      <li>
        Избегать id и использовать прямые ссылки, создавая частичный граф,
        предсталяющий ваш набор данных.
      </li>
      <li>
        Лениво подгружать объединенные модели с сервера, или лениво десериализовать вложенные
        модели из JSON-документов.
      </li>
    </ul>

    <p id="FAQ-bootstrap">
      <b class="header">Предзагрузка моделей</b>
      <br />
      Когда ваше приложение грузится, обычно имеется набор начальных моделей,
      которые точно понадобятся чтобы отобразить страницу.
      Вместо того, чтобы сделать еще один AJAX-запрос с помощью <a href="#Collection-fetch">fetch</a>,
      лучшим паттером будет иметь их данные уже загруженными в страницу.
      Тогда можно будет использовать <a href="#Collection-reset">reset</a>, чтобы наполнить коллекции 
      начальными данными. В DocumentCloud, в
      <a href="http://en.wikipedia.org/wiki/ERuby">ERB</a>-шаблоне для рабочего пространства,
      мы делаем так:
    </p>

<pre>
&lt;script&gt;
  var Accounts = new Backbone.Collection;
  Accounts.reset(&lt;%= @accounts.to_json %&gt;);
  var Projects = new Backbone.Collection;
  Projects.reset(&lt;%= @projects.to_json(:collaborators => true) %&gt;);
&lt;/script&gt;
</pre>

    <p>Не забудьте сделать <a href="http://mathiasbynens.be/notes/etago">escape</a>
    <tt>&lt;/</tt> внутри JSON-строки, чтобы предотвратить атаки с помощью внедрения JS.

    <p id="FAQ-extending">
      <b class="header">Расширяя Backbone</b>
      <br />
      Многие JS-библиотеки созданы быть отгороженным и замкнутыми.
      Вы взаимодействуете с ними вызывая их публичный API, но никогда не заглядываете
      во внутренности. Backbone.js <i>не является</i> такой библиотекой.
    </p>

    <p>
      Так как она служит фундаментом вашего приложения, подразумевается что вы
      будете расширять и улучшать её под себя — весь исходный код
      <a href="docs/backbone.html">аннотирован</a> чтобы облегчить это.
      Вы обнаружите, что там не так уж много всего, помимо функций ядра,
      и большинство из них может быть переопределено или улучшено, если вам нужно.
      Если вы поймаете себя на том, что добавляете методы в <tt>Backbone.Model.prototype</tt>,
      или создаете свои собственные базовые субклассы, не беспокойтесь — так и было задумано.
    </p>

    <p id="FAQ-mvc">
      <b class="header">Как Backbone соотносится с «традиционным» MVC?</b>
      <br />
      Разные имплементации паттерна
      <a href="http://ru.wikipedia.org/wiki/Model–View–Controller">Model-View-Controller</a>
      имеют тенденцию расходиться в определениях контроллера. Если это поможет — в
      Backbone, класс <a href="#View">представления</a> может считаться и чем-то вроде 
      контроллера, диспетчиризуя события, которые идут от UI, а HTML-шаблон — настоящим представлением.
      Мы назвали его «View», так как он отвечает за логически выделенный кусок UI,
      ответственный за контент одного DOM-элемента.
    </p>

    <p>
      Сравнивая общую структуру Backbone с серверным MVC-фреймворком, как <b>Rails</b>,
      получим примерно следующее:
    </p>

    <ul>
      <li>
        <b>Backbone.Model</b> — Подобна моделям в Rails, минус методы класса. Оборачивает строчку данных в бизнес-логику.
      </li>
      <li>
        <b>Backbone.Collection</b> — группа моделей на клиентской стороне, с сортировкой/фильтрацией/аггрегацией.
      </li>
      <li>
        <b>Backbone.Router</b> — <tt>routes.rb</tt> в Rails + экшены контроллера. Мапит адреса на функции.
      </li>
      <li>
        <b>Backbone.View</b> — Логиески выделенный, готовый к повторному использованию кусочек интерфейса. Часто, но не всегда, связан с моделью.
      </li>
      <li>
        <b>Клиентские шаблоны</b> — <tt>.html.erb</tt> из Rails, отрисовывающее кусочки HTML.
      </li>
    </ul>

    <p id="FAQ-this">
      <b class="header">Привязка "this"</b>
      <br />
      Вероятно, самая общая засада в JavaScript — это тот факт, 
      что когда функция передается как коллбек, её оригинальный контекст (<tt>this</tt>) теряется.
      С Backbone, имея дело с <a href="#Events">событиями</a> и коллбеками,
      часто полезно полагаться на 
      <a href="http://documentcloud.github.com/underscore/#bind">_.bind</a> и
      <a href="http://documentcloud.github.com/underscore/#bindAll">_.bindAll</a>
      из Underscore.js.
    </p>

    <p>
      Назначая обработчики на события Backbone, можно передать опциональный
      третий параметр, чтобы контекст <tt>this</tt>, с которым обработчик 
      будет потом вызван:
    </p>

<pre>
var MessageList = Backbone.View.extend({

  initialize: function() {
    var messages = this.collection;
    messages.on("reset", this.render, this);
    messages.on("add", this.addMessage, this);
    messages.on("remove", this.removeMessage, this);
  }

});

// Потом в приложении…

Inbox.messages.add(newMessage);
</pre>

    <p id="FAQ-rails">
      <b class="header">Работа Rails</b>
      <br />
      Backbone.js изначально был извлечен из 
      <a href="http://www.documentcloud.org">Rails-приложения</a>; заставить 
      модели на клиенте (в Backbone) корректно синхронизироваться с серверными
      (Rails) моделями не составляет никакого труда, но все же есть несколько вещей, 
      о которых следует знать.
    </p>

    <p>
      По умолчанию, Rails добавляет еще одну обертку в JSON-представлении
      моделей. Вы можете отключить это оборачивание, установив:
    </p>

<pre>
ActiveRecord::Base.include_root_in_json = false
</pre>

    <p>
      в конфигурации. Или переопределите 
      <a href="#Model-parse">parse</a> таким образом, чтобы вытаскивать атрибуты моделей из
      обертки. Похожим способом Backbone делает PUT и POST запросы с прямым JSON-представлением
      моделей, хотя Rails ожидает атрибуты завернутыми в пространство имен. Можно заставить
      контроллеры фильтровать атрибуты прямо из <tt>params</tt>, или переопределить 
      метод <a href="#Model-toJSON">toJSON</a> в Backbone, добавив 
      дополнительную обертку, которую ждет Rails.
    </p>

    <p>
      <br />
      <a href="http://documentcloud.org/" title="A DocumentCloud Project" style="background:none;">
        <img src="http://jashkenas.s3.amazonaws.com/images/a_documentcloud_project.png" alt="A DocumentCloud Project" style="position:relative;left:-10px;" />
      </a>
    </p>

  </div>

  <script src="test/vendor/underscore-1.3.1.js"></script>
  <script src="test/vendor/jquery-1.7.1.js"></script>
  <script src="test/vendor/json2.js"></script>
  <script src="backbone.js"></script>

  <script>
    // Set up the "play" buttons for each runnable code example.
    $(function() {
      $('.runnable').each(function() {
        var code = this;
        var button = '<div class="run" title="Run"></div>';
        $(button).insertBefore(code).bind('click', function(){
          eval($(code).text());
        });
      });
    });
  </script>

</body>
</html>